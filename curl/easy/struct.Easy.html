<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <meta name="description" content="API documentation for the Rust `Easy` struct in crate `curl`.">
    <meta name="keywords" content="rust, rustlang, rust-lang, Easy">

    <title>curl::easy::Easy - Rust</title>

    <link rel="stylesheet" type="text/css" href="../../rustdoc.css">
    <link rel="stylesheet" type="text/css" href="../../main.css">
    

    
    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    

    <nav class="sidebar">
        
        <p class='location'><a href='../index.html'>curl</a>::<wbr><a href='index.html'>easy</a></p><script>window.sidebarCurrent = {name: 'Easy', ty: 'struct', relpath: ''};</script><script defer src="sidebar-items.js"></script>
    </nav>

    <nav class="sub">
        <form class="search-form js-only">
            <div class="search-container">
                <input class="search-input" name="search"
                       autocomplete="off"
                       placeholder="Click or press ‘S’ to search, ‘?’ for more options…"
                       type="search">
            </div>
        </form>
    </nav>

    <section id='main' class="content struct">
<h1 class='fqn'><span class='in-band'>Struct <a href='../index.html'>curl</a>::<wbr><a href='index.html'>easy</a>::<wbr><a class='struct' href=''>Easy</a></span><span class='out-of-band'><span id='render-detail'>
                   <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">
                       [<span class='inner'>&#x2212;</span>]
                   </a>
               </span><a id='src-352' class='srclink' href='../../src/curl/easy.rs.html#92-95' title='goto source code'>[src]</a></span></h1>
<pre class='rust struct'>pub struct Easy { /* fields omitted */ }</pre><div class='docblock'><p>Raw bindings to a libcurl &quot;easy session&quot;.</p>

<p>This type corresponds to the <code>CURL</code> type in libcurl, and is probably what
you want for just sending off a simple HTTP request and fetching a response.
Each easy handle can be thought of as a large builder before calling the
final <code>perform</code> function.</p>

<p>There are many many configuration options for each <code>Easy</code> handle, and they
should all have their own documentation indicating what it affects and how
it interacts with other options. Some implementations of libcurl can use
this handle to interact with many different protocols, although by default
this crate only guarantees the HTTP/HTTPS protocols working.</p>

<p>Note that almost all methods on this structure which configure various
properties return a <code>Result</code>. This is largely used to detect whether the
underlying implementation of libcurl actually implements the option being
requested. If you&#39;re linked to a version of libcurl which doesn&#39;t support
the option, then an error will be returned. Some options also perform some
validation when they&#39;re set, and the error is returned through this vector.</p>

<h2 id='examples' class='section-header'><a href='#examples'>Examples</a></h2>
<p>Creating a handle which can be used later</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>curl</span>::<span class='ident'>easy</span>::<span class='ident'>Easy</span>;

<span class='kw'>let</span> <span class='ident'>handle</span> <span class='op'>=</span> <span class='ident'>Easy</span>::<span class='ident'>new</span>();</pre>

<p>Send an HTTP request, writing the response to stdout.</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>::{<span class='ident'>stdout</span>, <span class='ident'>Write</span>};

<span class='kw'>use</span> <span class='ident'>curl</span>::<span class='ident'>easy</span>::<span class='ident'>Easy</span>;

<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>handle</span> <span class='op'>=</span> <span class='ident'>Easy</span>::<span class='ident'>new</span>();
<span class='ident'>handle</span>.<span class='ident'>url</span>(<span class='string'>&quot;https://www.rust-lang.org/&quot;</span>).<span class='ident'>unwrap</span>();
<span class='ident'>handle</span>.<span class='ident'>write_function</span>(<span class='op'>|</span><span class='ident'>data</span><span class='op'>|</span> {
    <span class='prelude-val'>Ok</span>(<span class='ident'>stdout</span>().<span class='ident'>write</span>(<span class='ident'>data</span>).<span class='ident'>unwrap</span>())
}).<span class='ident'>unwrap</span>();
<span class='ident'>handle</span>.<span class='ident'>perform</span>().<span class='ident'>unwrap</span>();</pre>

<p>Collect all output of an HTTP request to a vector.</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>curl</span>::<span class='ident'>easy</span>::<span class='ident'>Easy</span>;

<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>data</span> <span class='op'>=</span> <span class='ident'>Vec</span>::<span class='ident'>new</span>();
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>handle</span> <span class='op'>=</span> <span class='ident'>Easy</span>::<span class='ident'>new</span>();
<span class='ident'>handle</span>.<span class='ident'>url</span>(<span class='string'>&quot;https://www.rust-lang.org/&quot;</span>).<span class='ident'>unwrap</span>();
{
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>transfer</span> <span class='op'>=</span> <span class='ident'>handle</span>.<span class='ident'>transfer</span>();
    <span class='ident'>transfer</span>.<span class='ident'>write_function</span>(<span class='op'>|</span><span class='ident'>new_data</span><span class='op'>|</span> {
        <span class='ident'>data</span>.<span class='ident'>extend_from_slice</span>(<span class='ident'>new_data</span>);
        <span class='prelude-val'>Ok</span>(<span class='ident'>new_data</span>.<span class='ident'>len</span>())
    }).<span class='ident'>unwrap</span>();
    <span class='ident'>transfer</span>.<span class='ident'>perform</span>().<span class='ident'>unwrap</span>();
}
<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{:?}&quot;</span>, <span class='ident'>data</span>);</pre>

<p>More examples of various properties of an HTTP request can be found on the
specific methods as well.</p>
</div><h2 id='methods'>Methods</h2><h3 class='impl'><span class='in-band'><code>impl <a class='struct' href='../../curl/easy/struct.Easy.html' title='curl::easy::Easy'>Easy</a></code></span><span class='out-of-band'><div class='ghost'></div><a id='src-450' class='srclink' href='../../src/curl/easy.rs.html#317-2809' title='goto source code'>[src]</a></span></h3>
<div class='impl-items'><h4 id='method.new' class='method'><span id='new.v' class='invisible'><code>fn <a href='#method.new' class='fnname'>new</a>() -&gt; <a class='struct' href='../../curl/easy/struct.Easy.html' title='curl::easy::Easy'>Easy</a></code></span></h4>
<div class='docblock'><p>Creates a new &quot;easy&quot; handle which is the core of almost all operations
in libcurl.</p>

<p>To use a handle, applications typically configure a number of options
followed by a call to <code>perform</code>. Options are preserved across calls to
<code>perform</code> and need to be reset manually (or via the <code>reset</code> method) if
this is not desired.</p>
</div><h4 id='method.verbose' class='method'><span id='verbose.v' class='invisible'><code>fn <a href='#method.verbose' class='fnname'>verbose</a>(&amp;mut self, verbose: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a>) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt;</code></span></h4>
<div class='docblock'><p>Configures this handle to have verbose output to help debug protocol
information.</p>

<p>By default output goes to stderr, but the <code>stderr</code> function on this type
can configure that. You can also use the <code>debug_function</code> method to get
all protocol data sent and received.</p>

<p>By default, this option is <code>false</code>.</p>
</div><h4 id='method.show_header' class='method'><span id='show_header.v' class='invisible'><code>fn <a href='#method.show_header' class='fnname'>show_header</a>(&amp;mut self, show: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a>) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt;</code></span></h4>
<div class='docblock'><p>Indicates whether header information is streamed to the output body of
this request.</p>

<p>This option is only relevant for protocols which have header metadata
(like http or ftp). It&#39;s not generally possible to extract headers
from the body if using this method, that use case should be intended for
the <code>header_function</code> method.</p>

<p>To set HTTP headers, use the <code>http_header</code> method.</p>

<p>By default, this option is <code>false</code> and corresponds to
<code>CURLOPT_HEADER</code>.</p>
</div><h4 id='method.progress' class='method'><span id='progress.v' class='invisible'><code>fn <a href='#method.progress' class='fnname'>progress</a>(&amp;mut self, progress: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a>) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt;</code></span></h4>
<div class='docblock'><p>Indicates whether a progress meter will be shown for requests done with
this handle.</p>

<p>This will also prevent the <code>progress_function</code> from being called.</p>

<p>By default this option is <code>false</code> and corresponds to
<code>CURLOPT_NOPROGRESS</code>.</p>
</div><h4 id='method.signal' class='method'><span id='signal.v' class='invisible'><code>fn <a href='#method.signal' class='fnname'>signal</a>(&amp;mut self, signal: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a>) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt;</code></span></h4>
<div class='docblock'><p>Inform libcurl whether or not it should install signal handlers or
attempt to use signals to perform library functions.</p>

<p>If this option is disabled then timeouts during name resolution will not
work unless libcurl is built against c-ares. Note that enabling this
option, however, may not cause libcurl to work with multiple threads.</p>

<p>By default this option is <code>false</code> and corresponds to <code>CURLOPT_NOSIGNAL</code>.
Note that this default is <strong>different than libcurl</strong> as it is intended
that this library is threadsafe by default. See the <a href="https://curl.haxx.se/libcurl/c/threadsafe.html">libcurl docs</a> for
some more information.</p>
</div><h4 id='method.wildcard_match' class='method'><span id='wildcard_match.v' class='invisible'><code>fn <a href='#method.wildcard_match' class='fnname'>wildcard_match</a>(&amp;mut self, m: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a>) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt;</code></span></h4>
<div class='docblock'><p>Indicates whether multiple files will be transferred based on the file
name pattern.</p>

<p>The last part of a filename uses fnmatch-like pattern matching.</p>

<p>By default this option is <code>false</code> and corresponds to
<code>CURLOPT_WILDCARDMATCH</code>.</p>
</div><h4 id='method.write_function' class='method'><span id='write_function.v' class='invisible'><code>fn <a href='#method.write_function' class='fnname'>write_function</a>&lt;F&gt;(&amp;mut self, f: F) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt; <span class='where'>where F: <a class='trait' href='https://doc.rust-lang.org/nightly/core/ops/trait.FnMut.html' title='core::ops::FnMut'>FnMut</a>(<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.slice.html'>&amp;[</a><a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.u8.html'>u8</a><a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.slice.html'>]</a>) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.usize.html'>usize</a>, <a class='enum' href='../../curl/easy/enum.WriteError.html' title='curl::easy::WriteError'>WriteError</a>&gt; + <a class='trait' href='https://doc.rust-lang.org/nightly/core/marker/trait.Send.html' title='core::marker::Send'>Send</a> + 'static</span></code></span></h4>
<div class='docblock'><p>Set callback for writing received data.</p>

<p>This callback function gets called by libcurl as soon as there is data
received that needs to be saved.</p>

<p>The callback function will be passed as much data as possible in all
invokes, but you must not make any assumptions. It may be one byte, it
may be thousands. If <code>show_header</code> is enabled, which makes header data
get passed to the write callback, you can get up to
<code>CURL_MAX_HTTP_HEADER</code> bytes of header data passed into it.  This
usually means 100K.</p>

<p>This function may be called with zero bytes data if the transferred file
is empty.</p>

<p>The callback should return the number of bytes actually taken care of.
If that amount differs from the amount passed to your callback function,
it&#39;ll signal an error condition to the library. This will cause the
transfer to get aborted and the libcurl function used will return
an error with <code>is_write_error</code>.</p>

<p>If your callback function returns <code>Err(WriteError::Pause)</code> it will cause
this transfer to become paused. See <code>unpause_write</code> for further details.</p>

<p>By default data is sent into the void, and this corresponds to the
<code>CURLOPT_WRITEFUNCTION</code> and <code>CURLOPT_WRITEDATA</code> options.</p>

<p>Note that the lifetime bound on this function is <code>&#39;static</code>, but that
is often too restrictive. To use stack data consider calling the
<code>transfer</code> method and then using <code>write_function</code> to configure a
callback that can reference stack-local data.</p>

<h1 id='examples-1' class='section-header'><a href='#examples-1'>Examples</a></h1>
<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>::{<span class='ident'>stdout</span>, <span class='ident'>Write</span>};
<span class='kw'>use</span> <span class='ident'>curl</span>::<span class='ident'>easy</span>::<span class='ident'>Easy</span>;

<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>handle</span> <span class='op'>=</span> <span class='ident'>Easy</span>::<span class='ident'>new</span>();
<span class='ident'>handle</span>.<span class='ident'>url</span>(<span class='string'>&quot;https://www.rust-lang.org/&quot;</span>).<span class='ident'>unwrap</span>();
<span class='ident'>handle</span>.<span class='ident'>write_function</span>(<span class='op'>|</span><span class='ident'>data</span><span class='op'>|</span> {
    <span class='prelude-val'>Ok</span>(<span class='ident'>stdout</span>().<span class='ident'>write</span>(<span class='ident'>data</span>).<span class='ident'>unwrap</span>())
}).<span class='ident'>unwrap</span>();
<span class='ident'>handle</span>.<span class='ident'>perform</span>().<span class='ident'>unwrap</span>();</pre>

<p>Writing to a stack-local buffer</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>::{<span class='ident'>stdout</span>, <span class='ident'>Write</span>};
<span class='kw'>use</span> <span class='ident'>curl</span>::<span class='ident'>easy</span>::<span class='ident'>Easy</span>;

<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>buf</span> <span class='op'>=</span> <span class='ident'>Vec</span>::<span class='ident'>new</span>();
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>handle</span> <span class='op'>=</span> <span class='ident'>Easy</span>::<span class='ident'>new</span>();
<span class='ident'>handle</span>.<span class='ident'>url</span>(<span class='string'>&quot;https://www.rust-lang.org/&quot;</span>).<span class='ident'>unwrap</span>();

<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>transfer</span> <span class='op'>=</span> <span class='ident'>handle</span>.<span class='ident'>transfer</span>();
<span class='ident'>transfer</span>.<span class='ident'>write_function</span>(<span class='op'>|</span><span class='ident'>data</span><span class='op'>|</span> {
    <span class='ident'>buf</span>.<span class='ident'>extend_from_slice</span>(<span class='ident'>data</span>);
    <span class='prelude-val'>Ok</span>(<span class='ident'>data</span>.<span class='ident'>len</span>())
}).<span class='ident'>unwrap</span>();
<span class='ident'>transfer</span>.<span class='ident'>perform</span>().<span class='ident'>unwrap</span>();</pre>
</div><h4 id='method.read_function' class='method'><span id='read_function.v' class='invisible'><code>fn <a href='#method.read_function' class='fnname'>read_function</a>&lt;F&gt;(&amp;mut self, f: F) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt; <span class='where'>where F: <a class='trait' href='https://doc.rust-lang.org/nightly/core/ops/trait.FnMut.html' title='core::ops::FnMut'>FnMut</a>(<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.slice.html'>&amp;mut [</a><a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.u8.html'>u8</a><a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.slice.html'>]</a>) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.usize.html'>usize</a>, <a class='enum' href='../../curl/easy/enum.ReadError.html' title='curl::easy::ReadError'>ReadError</a>&gt; + <a class='trait' href='https://doc.rust-lang.org/nightly/core/marker/trait.Send.html' title='core::marker::Send'>Send</a> + 'static</span></code></span></h4>
<div class='docblock'><p>Read callback for data uploads.</p>

<p>This callback function gets called by libcurl as soon as it needs to
read data in order to send it to the peer - like if you ask it to upload
or post data to the server.</p>

<p>Your function must then return the actual number of bytes that it stored
in that memory area. Returning 0 will signal end-of-file to the library
and cause it to stop the current transfer.</p>

<p>If you stop the current transfer by returning 0 &quot;pre-maturely&quot; (i.e
before the server expected it, like when you&#39;ve said you will upload N
bytes and you upload less than N bytes), you may experience that the
server &quot;hangs&quot; waiting for the rest of the data that won&#39;t come.</p>

<p>The read callback may return <code>Err(ReadError::Abort)</code> to stop the
current operation immediately, resulting in a <code>is_aborted_by_callback</code>
error code from the transfer.</p>

<p>The callback can return <code>Err(ReadError::Pause)</code> to cause reading from
this connection to pause. See <code>unpause_read</code> for further details.</p>

<p>By default data not input, and this corresponds to the
<code>CURLOPT_READFUNCTION</code> and <code>CURLOPT_READDATA</code> options.</p>

<p>Note that the lifetime bound on this function is <code>&#39;static</code>, but that
is often too restrictive. To use stack data consider calling the
<code>transfer</code> method and then using <code>read_function</code> to configure a
callback that can reference stack-local data.</p>

<h1 id='examples-2' class='section-header'><a href='#examples-2'>Examples</a></h1>
<p>Read input from stdin</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>::{<span class='ident'>stdin</span>, <span class='ident'>Read</span>};
<span class='kw'>use</span> <span class='ident'>curl</span>::<span class='ident'>easy</span>::<span class='ident'>Easy</span>;

<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>handle</span> <span class='op'>=</span> <span class='ident'>Easy</span>::<span class='ident'>new</span>();
<span class='ident'>handle</span>.<span class='ident'>url</span>(<span class='string'>&quot;https://example.com/login&quot;</span>).<span class='ident'>unwrap</span>();
<span class='ident'>handle</span>.<span class='ident'>read_function</span>(<span class='op'>|</span><span class='ident'>into</span><span class='op'>|</span> {
    <span class='prelude-val'>Ok</span>(<span class='ident'>stdin</span>().<span class='ident'>read</span>(<span class='ident'>into</span>).<span class='ident'>unwrap</span>())
}).<span class='ident'>unwrap</span>();
<span class='ident'>handle</span>.<span class='ident'>post</span>(<span class='bool-val'>true</span>).<span class='ident'>unwrap</span>();
<span class='ident'>handle</span>.<span class='ident'>perform</span>().<span class='ident'>unwrap</span>();</pre>

<p>Reading from stack-local data:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>::{<span class='ident'>stdin</span>, <span class='ident'>Read</span>};
<span class='kw'>use</span> <span class='ident'>curl</span>::<span class='ident'>easy</span>::<span class='ident'>Easy</span>;

<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>data_to_upload</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='string'>b&quot;foobar&quot;</span>[..];
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>handle</span> <span class='op'>=</span> <span class='ident'>Easy</span>::<span class='ident'>new</span>();
<span class='ident'>handle</span>.<span class='ident'>url</span>(<span class='string'>&quot;https://example.com/login&quot;</span>).<span class='ident'>unwrap</span>();
<span class='ident'>handle</span>.<span class='ident'>post</span>(<span class='bool-val'>true</span>).<span class='ident'>unwrap</span>();

<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>transfer</span> <span class='op'>=</span> <span class='ident'>handle</span>.<span class='ident'>transfer</span>();
<span class='ident'>transfer</span>.<span class='ident'>read_function</span>(<span class='op'>|</span><span class='ident'>into</span><span class='op'>|</span> {
    <span class='prelude-val'>Ok</span>(<span class='ident'>data_to_upload</span>.<span class='ident'>read</span>(<span class='ident'>into</span>).<span class='ident'>unwrap</span>())
}).<span class='ident'>unwrap</span>();
<span class='ident'>transfer</span>.<span class='ident'>perform</span>().<span class='ident'>unwrap</span>();</pre>
</div><h4 id='method.seek_function' class='method'><span id='seek_function.v' class='invisible'><code>fn <a href='#method.seek_function' class='fnname'>seek_function</a>&lt;F&gt;(&amp;mut self, f: F) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt; <span class='where'>where F: <a class='trait' href='https://doc.rust-lang.org/nightly/core/ops/trait.FnMut.html' title='core::ops::FnMut'>FnMut</a>(<a class='enum' href='https://doc.rust-lang.org/nightly/std/io/enum.SeekFrom.html' title='std::io::SeekFrom'>SeekFrom</a>) -&gt; <a class='enum' href='../../curl/easy/enum.SeekResult.html' title='curl::easy::SeekResult'>SeekResult</a> + <a class='trait' href='https://doc.rust-lang.org/nightly/core/marker/trait.Send.html' title='core::marker::Send'>Send</a> + 'static</span></code></span></h4>
<div class='docblock'><p>User callback for seeking in input stream.</p>

<p>This function gets called by libcurl to seek to a certain position in
the input stream and can be used to fast forward a file in a resumed
upload (instead of reading all uploaded bytes with the normal read
function/callback). It is also called to rewind a stream when data has
already been sent to the server and needs to be sent again. This may
happen when doing a HTTP PUT or POST with a multi-pass authentication
method, or when an existing HTTP connection is reused too late and the
server closes the connection.</p>

<p>The callback function must return <code>SeekResult::Ok</code> on success,
<code>SeekResult::Fail</code> to cause the upload operation to fail or
<code>SeekResult::CantSeek</code> to indicate that while the seek failed, libcurl
is free to work around the problem if possible. The latter can sometimes
be done by instead reading from the input or similar.</p>

<p>By default data this option is not set, and this corresponds to the
<code>CURLOPT_SEEKFUNCTION</code> and <code>CURLOPT_SEEKDATA</code> options.</p>

<p>Note that the lifetime bound on this function is <code>&#39;static</code>, but that
is often too restrictive. To use stack data consider calling the
<code>transfer</code> method and then using <code>seek_function</code> to configure a
callback that can reference stack-local data.</p>
</div><h4 id='method.progress_function' class='method'><span id='progress_function.v' class='invisible'><code>fn <a href='#method.progress_function' class='fnname'>progress_function</a>&lt;F&gt;(&amp;mut self, f: F) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt; <span class='where'>where F: <a class='trait' href='https://doc.rust-lang.org/nightly/core/ops/trait.FnMut.html' title='core::ops::FnMut'>FnMut</a>(<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.f64.html'>f64</a>, <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.f64.html'>f64</a>, <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.f64.html'>f64</a>, <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.f64.html'>f64</a>) -&gt; <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a> + <a class='trait' href='https://doc.rust-lang.org/nightly/core/marker/trait.Send.html' title='core::marker::Send'>Send</a> + 'static</span></code></span></h4>
<div class='docblock'><p>Callback to progress meter function</p>

<p>This function gets called by libcurl instead of its internal equivalent
with a frequent interval. While data is being transferred it will be
called very frequently, and during slow periods like when nothing is
being transferred it can slow down to about one call per second.</p>

<p>The callback gets told how much data libcurl will transfer and has
transferred, in number of bytes. The first argument is the total number
of bytes libcurl expects to download in this transfer. The second
argument is the number of bytes downloaded so far. The third argument is
the total number of bytes libcurl expects to upload in this transfer.
The fourth argument is the number of bytes uploaded so far.</p>

<p>Unknown/unused argument values passed to the callback will be set to
zero (like if you only download data, the upload size will remain 0).
Many times the callback will be called one or more times first, before
it knows the data sizes so a program must be made to handle that.</p>

<p>Returning <code>false</code> from this callback will cause libcurl to abort the
transfer and return <code>is_aborted_by_callback</code>.</p>

<p>If you transfer data with the multi interface, this function will not be
called during periods of idleness unless you call the appropriate
libcurl function that performs transfers.</p>

<p><code>noprogress</code> must be set to 0 to make this function actually get
called.</p>

<p>By default this function calls an internal method and corresponds to
<code>CURLOPT_PROGRESSFUNCTION</code> and <code>CURLOPT_PROGRESSDATA</code>.</p>

<p>Note that the lifetime bound on this function is <code>&#39;static</code>, but that
is often too restrictive. To use stack data consider calling the
<code>transfer</code> method and then using <code>progress_function</code> to configure a
callback that can reference stack-local data.</p>
</div><h4 id='method.ssl_ctx_function' class='method'><span id='ssl_ctx_function.v' class='invisible'><code>fn <a href='#method.ssl_ctx_function' class='fnname'>ssl_ctx_function</a>&lt;F&gt;(&amp;mut self, f: F) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt; <span class='where'>where F: <a class='trait' href='https://doc.rust-lang.org/nightly/core/ops/trait.FnMut.html' title='core::ops::FnMut'>FnMut</a>(<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.pointer.html'>*mut </a><a class='enum' href='../../libc/enum.c_void.html' title='libc::c_void'>c_void</a>) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt; + <a class='trait' href='https://doc.rust-lang.org/nightly/core/marker/trait.Send.html' title='core::marker::Send'>Send</a> + 'static</span></code></span></h4>
<div class='docblock'><p>Callback to SSL context</p>

<p>This callback function gets called by libcurl just before the
initialization of an SSL connection after having processed all
other SSL related options to give a last chance to an
application to modify the behaviour of the SSL
initialization. The <code>ssl_ctx</code> parameter is actually a pointer
to the SSL library&#39;s SSL_CTX. If an error is returned from the
callback no attempt to establish a connection is made and the
perform operation will return the callback&#39;s error code.</p>

<p>This function will get called on all new connections made to a
server, during the SSL negotiation. The SSL_CTX pointer will
be a new one every time.</p>

<p>To use this properly, a non-trivial amount of knowledge of
your SSL library is necessary. For example, you can use this
function to call library-specific callbacks to add additional
validation code for certificates, and even to change the
actual URI of a HTTPS request.</p>

<p>By default this function calls an internal method and
corresponds to <code>CURLOPT_SSL_CTX_FUNCTION</code> and
<code>CURLOPT_SSL_CTX_DATA</code>.</p>

<p>Note that the lifetime bound on this function is <code>&#39;static</code>, but that
is often too restrictive. To use stack data consider calling the
<code>transfer</code> method and then using <code>progress_function</code> to configure a
callback that can reference stack-local data.</p>
</div><h4 id='method.debug_function' class='method'><span id='debug_function.v' class='invisible'><code>fn <a href='#method.debug_function' class='fnname'>debug_function</a>&lt;F&gt;(&amp;mut self, f: F) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt; <span class='where'>where F: <a class='trait' href='https://doc.rust-lang.org/nightly/core/ops/trait.FnMut.html' title='core::ops::FnMut'>FnMut</a>(<a class='enum' href='../../curl/easy/enum.InfoType.html' title='curl::easy::InfoType'>InfoType</a>, <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.slice.html'>&amp;[</a><a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.u8.html'>u8</a><a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.slice.html'>]</a>) + <a class='trait' href='https://doc.rust-lang.org/nightly/core/marker/trait.Send.html' title='core::marker::Send'>Send</a> + 'static</span></code></span></h4>
<div class='docblock'><p>Specify a debug callback</p>

<p><code>debug_function</code> replaces the standard debug function used when
<code>verbose</code> is in effect. This callback receives debug information,
as specified in the type argument.</p>

<p>By default this option is not set and corresponds to the
<code>CURLOPT_DEBUGFUNCTION</code> and <code>CURLOPT_DEBUGDATA</code> options.</p>

<p>Note that the lifetime bound on this function is <code>&#39;static</code>, but that
is often too restrictive. To use stack data consider calling the
<code>transfer</code> method and then using <code>debug_function</code> to configure a
callback that can reference stack-local data.</p>
</div><h4 id='method.header_function' class='method'><span id='header_function.v' class='invisible'><code>fn <a href='#method.header_function' class='fnname'>header_function</a>&lt;F&gt;(&amp;mut self, f: F) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt; <span class='where'>where F: <a class='trait' href='https://doc.rust-lang.org/nightly/core/ops/trait.FnMut.html' title='core::ops::FnMut'>FnMut</a>(<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.slice.html'>&amp;[</a><a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.u8.html'>u8</a><a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.slice.html'>]</a>) -&gt; <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a> + <a class='trait' href='https://doc.rust-lang.org/nightly/core/marker/trait.Send.html' title='core::marker::Send'>Send</a> + 'static</span></code></span></h4>
<div class='docblock'><p>Callback that receives header data</p>

<p>This function gets called by libcurl as soon as it has received header
data. The header callback will be called once for each header and only
complete header lines are passed on to the callback. Parsing headers is
very easy using this. If this callback returns <code>false</code> it&#39;ll signal an
error to the library. This will cause the transfer to get aborted and
the libcurl function in progress will return <code>is_write_error</code>.</p>

<p>A complete HTTP header that is passed to this function can be up to
CURL_MAX_HTTP_HEADER (100K) bytes.</p>

<p>It&#39;s important to note that the callback will be invoked for the headers
of all responses received after initiating a request and not just the
final response. This includes all responses which occur during
authentication negotiation. If you need to operate on only the headers
from the final response, you will need to collect headers in the
callback yourself and use HTTP status lines, for example, to delimit
response boundaries.</p>

<p>When a server sends a chunked encoded transfer, it may contain a
trailer. That trailer is identical to a HTTP header and if such a
trailer is received it is passed to the application using this callback
as well. There are several ways to detect it being a trailer and not an
ordinary header: 1) it comes after the response-body. 2) it comes after
the final header line (CR LF) 3) a Trailer: header among the regular
response-headers mention what header(s) to expect in the trailer.</p>

<p>For non-HTTP protocols like FTP, POP3, IMAP and SMTP this function will
get called with the server responses to the commands that libcurl sends.</p>

<p>By default this option is not set and corresponds to the
<code>CURLOPT_HEADERFUNCTION</code> and <code>CURLOPT_HEADERDATA</code> options.</p>

<p>Note that the lifetime bound on this function is <code>&#39;static</code>, but that
is often too restrictive. To use stack data consider calling the
<code>transfer</code> method and then using <code>header_function</code> to configure a
callback that can reference stack-local data.</p>

<h1 id='examples-3' class='section-header'><a href='#examples-3'>Examples</a></h1>
<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>str</span>;

<span class='kw'>use</span> <span class='ident'>curl</span>::<span class='ident'>easy</span>::<span class='ident'>Easy</span>;

<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>handle</span> <span class='op'>=</span> <span class='ident'>Easy</span>::<span class='ident'>new</span>();
<span class='ident'>handle</span>.<span class='ident'>url</span>(<span class='string'>&quot;https://www.rust-lang.org/&quot;</span>).<span class='ident'>unwrap</span>();
<span class='ident'>handle</span>.<span class='ident'>header_function</span>(<span class='op'>|</span><span class='ident'>header</span><span class='op'>|</span> {
    <span class='macro'>print</span><span class='macro'>!</span>(<span class='string'>&quot;header: {}&quot;</span>, <span class='ident'>str</span>::<span class='ident'>from_utf8</span>(<span class='ident'>header</span>).<span class='ident'>unwrap</span>());
    <span class='bool-val'>true</span>
}).<span class='ident'>unwrap</span>();
<span class='ident'>handle</span>.<span class='ident'>perform</span>().<span class='ident'>unwrap</span>();</pre>

<p>Collecting headers to a stack local vector</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>str</span>;

<span class='kw'>use</span> <span class='ident'>curl</span>::<span class='ident'>easy</span>::<span class='ident'>Easy</span>;

<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>headers</span> <span class='op'>=</span> <span class='ident'>Vec</span>::<span class='ident'>new</span>();
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>handle</span> <span class='op'>=</span> <span class='ident'>Easy</span>::<span class='ident'>new</span>();
<span class='ident'>handle</span>.<span class='ident'>url</span>(<span class='string'>&quot;https://www.rust-lang.org/&quot;</span>).<span class='ident'>unwrap</span>();

{
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>transfer</span> <span class='op'>=</span> <span class='ident'>handle</span>.<span class='ident'>transfer</span>();
    <span class='ident'>transfer</span>.<span class='ident'>header_function</span>(<span class='op'>|</span><span class='ident'>header</span><span class='op'>|</span> {
        <span class='ident'>headers</span>.<span class='ident'>push</span>(<span class='ident'>str</span>::<span class='ident'>from_utf8</span>(<span class='ident'>header</span>).<span class='ident'>unwrap</span>().<span class='ident'>to_string</span>());
        <span class='bool-val'>true</span>
    }).<span class='ident'>unwrap</span>();
    <span class='ident'>transfer</span>.<span class='ident'>perform</span>().<span class='ident'>unwrap</span>();
}

<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{:?}&quot;</span>, <span class='ident'>headers</span>);</pre>
</div><h4 id='method.fail_on_error' class='method'><span id='fail_on_error.v' class='invisible'><code>fn <a href='#method.fail_on_error' class='fnname'>fail_on_error</a>(&amp;mut self, fail: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a>) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt;</code></span></h4>
<div class='docblock'><p>Indicates whether this library will fail on HTTP response codes &gt;= 400.</p>

<p>This method is not fail-safe especially when authentication is involved.</p>

<p>By default this option is <code>false</code> and corresponds to
<code>CURLOPT_FAILONERROR</code>.</p>
</div><h4 id='method.url' class='method'><span id='url.v' class='invisible'><code>fn <a href='#method.url' class='fnname'>url</a>(&amp;mut self, url: &amp;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.str.html'>str</a>) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt;</code></span></h4>
<div class='docblock'><p>Provides the URL which this handle will work with.</p>

<p>The string provided must be URL-encoded with the format:</p>

<pre><code class="language-text">scheme://host:port/path
</code></pre>

<p>The syntax is not validated as part of this function and that is
deferred until later.</p>

<p>By default this option is not set and <code>perform</code> will not work until it
is set. This option corresponds to <code>CURLOPT_URL</code>.</p>
</div><h4 id='method.port' class='method'><span id='port.v' class='invisible'><code>fn <a href='#method.port' class='fnname'>port</a>(&amp;mut self, port: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.u16.html'>u16</a>) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt;</code></span></h4>
<div class='docblock'><p>Configures the port number to connect to, instead of the one specified
in the URL or the default of the protocol.</p>
</div><h4 id='method.proxy' class='method'><span id='proxy.v' class='invisible'><code>fn <a href='#method.proxy' class='fnname'>proxy</a>(&amp;mut self, url: &amp;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.str.html'>str</a>) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt;</code></span></h4>
<div class='docblock'><p>Provide the URL of a proxy to use.</p>

<p>By default this option is not set and corresponds to <code>CURLOPT_PROXY</code>.</p>
</div><h4 id='method.proxy_port' class='method'><span id='proxy_port.v' class='invisible'><code>fn <a href='#method.proxy_port' class='fnname'>proxy_port</a>(&amp;mut self, port: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.u16.html'>u16</a>) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt;</code></span></h4>
<div class='docblock'><p>Provide port number the proxy is listening on.</p>

<p>By default this option is not set (the default port for the proxy
protocol is used) and corresponds to <code>CURLOPT_PROXYPORT</code>.</p>
</div><h4 id='method.proxy_type' class='method'><span id='proxy_type.v' class='invisible'><code>fn <a href='#method.proxy_type' class='fnname'>proxy_type</a>(&amp;mut self, kind: <a class='enum' href='../../curl/easy/enum.ProxyType.html' title='curl::easy::ProxyType'>ProxyType</a>) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt;</code></span></h4>
<div class='docblock'><p>Indicates the type of proxy being used.</p>

<p>By default this option is <code>ProxyType::Http</code> and corresponds to
<code>CURLOPT_PROXYTYPE</code>.</p>
</div><h4 id='method.noproxy' class='method'><span id='noproxy.v' class='invisible'><code>fn <a href='#method.noproxy' class='fnname'>noproxy</a>(&amp;mut self, skip: &amp;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.str.html'>str</a>) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt;</code></span></h4>
<div class='docblock'><p>Provide a list of hosts that should not be proxied to.</p>

<p>This string is a comma-separated list of hosts which should not use the
proxy specified for connections. A single <code>*</code> character is also accepted
as a wildcard for all hosts.</p>

<p>By default this option is not set and corresponds to
<code>CURLOPT_NOPROXY</code>.</p>
</div><h4 id='method.http_proxy_tunnel' class='method'><span id='http_proxy_tunnel.v' class='invisible'><code>fn <a href='#method.http_proxy_tunnel' class='fnname'>http_proxy_tunnel</a>(&amp;mut self, tunnel: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a>) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt;</code></span></h4>
<div class='docblock'><p>Inform curl whether it should tunnel all operations through the proxy.</p>

<p>This essentially means that a <code>CONNECT</code> is sent to the proxy for all
outbound requests.</p>

<p>By default this option is <code>false</code> and corresponds to
<code>CURLOPT_HTTPPROXYTUNNEL</code>.</p>
</div><h4 id='method.interface' class='method'><span id='interface.v' class='invisible'><code>fn <a href='#method.interface' class='fnname'>interface</a>(&amp;mut self, interface: &amp;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.str.html'>str</a>) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt;</code></span></h4>
<div class='docblock'><p>Tell curl which interface to bind to for an outgoing network interface.</p>

<p>The interface name, IP address, or host name can be specified here.</p>

<p>By default this option is not set and corresponds to
<code>CURLOPT_INTERFACE</code>.</p>
</div><h4 id='method.set_local_port' class='method'><span id='set_local_port.v' class='invisible'><code>fn <a href='#method.set_local_port' class='fnname'>set_local_port</a>(&amp;mut self, port: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.u16.html'>u16</a>) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt;</code></span></h4>
<div class='docblock'><p>Indicate which port should be bound to locally for this connection.</p>

<p>By default this option is 0 (any port) and corresponds to
<code>CURLOPT_LOCALPORT</code>.</p>
</div><h4 id='method.local_port_range' class='method'><span id='local_port_range.v' class='invisible'><code>fn <a href='#method.local_port_range' class='fnname'>local_port_range</a>(&amp;mut self, range: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.u16.html'>u16</a>) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt;</code></span></h4>
<div class='docblock'><p>Indicates the number of attempts libcurl will perform to find a working
port number.</p>

<p>By default this option is 1 and corresponds to
<code>CURLOPT_LOCALPORTRANGE</code>.</p>
</div><h4 id='method.dns_cache_timeout' class='method'><span id='dns_cache_timeout.v' class='invisible'><code>fn <a href='#method.dns_cache_timeout' class='fnname'>dns_cache_timeout</a>(&amp;mut self, dur: <a class='struct' href='https://doc.rust-lang.org/nightly/std/time/duration/struct.Duration.html' title='std::time::duration::Duration'>Duration</a>) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt;</code></span></h4>
<div class='docblock'><p>Sets the timeout of how long name resolves will be kept in memory.</p>

<p>This is distinct from DNS TTL options and is entirely speculative.</p>

<p>By default this option is 60s and corresponds to
<code>CURLOPT_DNS_CACHE_TIMEOUT</code>.</p>
</div><h4 id='method.buffer_size' class='method'><span id='buffer_size.v' class='invisible'><code>fn <a href='#method.buffer_size' class='fnname'>buffer_size</a>(&amp;mut self, size: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.usize.html'>usize</a>) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt;</code></span></h4>
<div class='docblock'><p>Specify the preferred receive buffer size, in bytes.</p>

<p>This is treated as a request, not an order, and the main point of this
is that the write callback may get called more often with smaller
chunks.</p>

<p>By default this option is the maximum write size and corresopnds to
<code>CURLOPT_BUFFERSIZE</code>.</p>
</div><h4 id='method.tcp_nodelay' class='method'><span id='tcp_nodelay.v' class='invisible'><code>fn <a href='#method.tcp_nodelay' class='fnname'>tcp_nodelay</a>(&amp;mut self, enable: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a>) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt;</code></span></h4>
<div class='docblock'><p>Configures whether the TCP_NODELAY option is set, or Nagle&#39;s algorithm
is disabled.</p>

<p>The purpose of Nagle&#39;s algorithm is to minimize the number of small
packet&#39;s on the network, and disabling this may be less efficient in
some situations.</p>

<p>By default this option is <code>false</code> and corresponds to
<code>CURLOPT_TCP_NODELAY</code>.</p>
</div><h4 id='method.address_scope' class='method'><span id='address_scope.v' class='invisible'><code>fn <a href='#method.address_scope' class='fnname'>address_scope</a>(&amp;mut self, scope: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.u32.html'>u32</a>) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt;</code></span></h4>
<div class='docblock'><p>Configures the scope for local IPv6 addresses.</p>

<p>Sets the scope_id value to use when connecting to IPv6 or link-local
addresses.</p>

<p>By default this value is 0 and corresponds to <code>CURLOPT_ADDRESS_SCOPE</code></p>
</div><h4 id='method.username' class='method'><span id='username.v' class='invisible'><code>fn <a href='#method.username' class='fnname'>username</a>(&amp;mut self, user: &amp;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.str.html'>str</a>) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt;</code></span></h4>
<div class='docblock'><p>Configures the username to pass as authentication for this connection.</p>

<p>By default this value is not set and corresponds to <code>CURLOPT_USERNAME</code>.</p>
</div><h4 id='method.password' class='method'><span id='password.v' class='invisible'><code>fn <a href='#method.password' class='fnname'>password</a>(&amp;mut self, pass: &amp;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.str.html'>str</a>) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt;</code></span></h4>
<div class='docblock'><p>Configures the password to pass as authentication for this connection.</p>

<p>By default this value is not set and corresponds to <code>CURLOPT_PASSWORD</code>.</p>
</div><h4 id='method.http_auth' class='method'><span id='http_auth.v' class='invisible'><code>fn <a href='#method.http_auth' class='fnname'>http_auth</a>(&amp;mut self, auth: &amp;<a class='struct' href='../../curl/easy/struct.Auth.html' title='curl::easy::Auth'>Auth</a>) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt;</code></span></h4>
<div class='docblock'><p>Set HTTP server authentication methods to try</p>

<p>If more than one method is set, libcurl will first query the site to see
which authentication methods it supports and then pick the best one you
allow it to use. For some methods, this will induce an extra network
round-trip. Set the actual name and password with the <code>password</code> and
<code>username</code> methods.</p>

<p>For authentication with a proxy, see <code>proxy_auth</code>.</p>

<p>By default this value is basic and corresponds to <code>CURLOPT_HTTPAUTH</code>.</p>
</div><h4 id='method.proxy_username' class='method'><span id='proxy_username.v' class='invisible'><code>fn <a href='#method.proxy_username' class='fnname'>proxy_username</a>(&amp;mut self, user: &amp;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.str.html'>str</a>) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt;</code></span></h4>
<div class='docblock'><p>Configures the proxy username to pass as authentication for this
connection.</p>

<p>By default this value is not set and corresponds to
<code>CURLOPT_PROXYUSERNAME</code>.</p>
</div><h4 id='method.proxy_password' class='method'><span id='proxy_password.v' class='invisible'><code>fn <a href='#method.proxy_password' class='fnname'>proxy_password</a>(&amp;mut self, pass: &amp;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.str.html'>str</a>) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt;</code></span></h4>
<div class='docblock'><p>Configures the proxy password to pass as authentication for this
connection.</p>

<p>By default this value is not set and corresponds to
<code>CURLOPT_PROXYPASSWORD</code>.</p>
</div><h4 id='method.proxy_auth' class='method'><span id='proxy_auth.v' class='invisible'><code>fn <a href='#method.proxy_auth' class='fnname'>proxy_auth</a>(&amp;mut self, auth: &amp;<a class='struct' href='../../curl/easy/struct.Auth.html' title='curl::easy::Auth'>Auth</a>) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt;</code></span></h4>
<div class='docblock'><p>Set HTTP proxy authentication methods to try</p>

<p>If more than one method is set, libcurl will first query the site to see
which authentication methods it supports and then pick the best one you
allow it to use. For some methods, this will induce an extra network
round-trip. Set the actual name and password with the <code>proxy_password</code>
and <code>proxy_username</code> methods.</p>

<p>By default this value is basic and corresponds to <code>CURLOPT_PROXYAUTH</code>.</p>
</div><h4 id='method.autoreferer' class='method'><span id='autoreferer.v' class='invisible'><code>fn <a href='#method.autoreferer' class='fnname'>autoreferer</a>(&amp;mut self, enable: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a>) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt;</code></span></h4>
<div class='docblock'><p>Indicates whether the referer header is automatically updated</p>

<p>By default this option is <code>false</code> and corresponds to
<code>CURLOPT_AUTOREFERER</code>.</p>
</div><h4 id='method.accept_encoding' class='method'><span id='accept_encoding.v' class='invisible'><code>fn <a href='#method.accept_encoding' class='fnname'>accept_encoding</a>(&amp;mut self, encoding: &amp;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.str.html'>str</a>) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt;</code></span></h4>
<div class='docblock'><p>Enables automatic decompression of HTTP downloads.</p>

<p>Sets the contents of the Accept-Encoding header sent in an HTTP request.
This enables decoding of a response with Content-Encoding.</p>

<p>Currently supported encoding are <code>identity</code>, <code>zlib</code>, and <code>gzip</code>. A
zero-length string passed in will send all accepted encodings.</p>

<p>By default this option is not set and corresponds to
<code>CURLOPT_ACCEPT_ENCODING</code>.</p>
</div><h4 id='method.transfer_encoding' class='method'><span id='transfer_encoding.v' class='invisible'><code>fn <a href='#method.transfer_encoding' class='fnname'>transfer_encoding</a>(&amp;mut self, enable: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a>) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt;</code></span></h4>
<div class='docblock'><p>Request the HTTP Transfer Encoding.</p>

<p>By default this option is <code>false</code> and corresponds to
<code>CURLOPT_TRANSFER_ENCODING</code>.</p>
</div><h4 id='method.follow_location' class='method'><span id='follow_location.v' class='invisible'><code>fn <a href='#method.follow_location' class='fnname'>follow_location</a>(&amp;mut self, enable: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a>) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt;</code></span></h4>
<div class='docblock'><p>Follow HTTP 3xx redirects.</p>

<p>Indicates whether any <code>Location</code> headers in the response should get
followed.</p>

<p>By default this option is <code>false</code> and corresponds to
<code>CURLOPT_FOLLOWLOCATION</code>.</p>
</div><h4 id='method.unrestricted_auth' class='method'><span id='unrestricted_auth.v' class='invisible'><code>fn <a href='#method.unrestricted_auth' class='fnname'>unrestricted_auth</a>(&amp;mut self, enable: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a>) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt;</code></span></h4>
<div class='docblock'><p>Send credentials to hosts other than the first as well.</p>

<p>Sends username/password credentials even when the host changes as part
of a redirect.</p>

<p>By default this option is <code>false</code> and corresponds to
<code>CURLOPT_UNRESTRICTED_AUTH</code>.</p>
</div><h4 id='method.max_redirections' class='method'><span id='max_redirections.v' class='invisible'><code>fn <a href='#method.max_redirections' class='fnname'>max_redirections</a>(&amp;mut self, max: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.u32.html'>u32</a>) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt;</code></span></h4>
<div class='docblock'><p>Set the maximum number of redirects allowed.</p>

<p>A value of 0 will refuse any redirect.</p>

<p>By default this option is <code>-1</code> (unlimited) and corresponds to
<code>CURLOPT_MAXREDIRS</code>.</p>
</div><h4 id='method.put' class='method'><span id='put.v' class='invisible'><code>fn <a href='#method.put' class='fnname'>put</a>(&amp;mut self, enable: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a>) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt;</code></span></h4>
<div class='docblock'><p>Make an HTTP PUT request.</p>

<p>By default this option is <code>false</code> and corresponds to <code>CURLOPT_PUT</code>.</p>
</div><h4 id='method.post' class='method'><span id='post.v' class='invisible'><code>fn <a href='#method.post' class='fnname'>post</a>(&amp;mut self, enable: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a>) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt;</code></span></h4>
<div class='docblock'><p>Make an HTTP POST request.</p>

<p>This will also make the library use the
<code>Content-Type: application/x-www-form-urlencoded</code> header.</p>

<p>POST data can be specified through <code>post_fields</code> or by specifying a read
function.</p>

<p>By default this option is <code>false</code> and corresponds to <code>CURLOPT_POST</code>.</p>
</div><h4 id='method.post_fields_copy' class='method'><span id='post_fields_copy.v' class='invisible'><code>fn <a href='#method.post_fields_copy' class='fnname'>post_fields_copy</a>(&amp;mut self, data: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.slice.html'>&amp;[</a><a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.u8.html'>u8</a><a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.slice.html'>]</a>) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt;</code></span></h4>
<div class='docblock'><p>Configures the data that will be uploaded as part of a POST.</p>

<p>Note that the data is copied into this handle and if that&#39;s not desired
then the read callbacks can be used instead.</p>

<p>By default this option is not set and corresponds to
<code>CURLOPT_COPYPOSTFIELDS</code>.</p>
</div><h4 id='method.post_field_size' class='method'><span id='post_field_size.v' class='invisible'><code>fn <a href='#method.post_field_size' class='fnname'>post_field_size</a>(&amp;mut self, size: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.u64.html'>u64</a>) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt;</code></span></h4>
<div class='docblock'><p>Configures the size of data that&#39;s going to be uploaded as part of a
POST operation.</p>

<p>This is called automaticsally as part of <code>post_fields</code> and should only
be called if data is being provided in a read callback (and even then
it&#39;s optional).</p>

<p>By default this option is not set and corresponds to
<code>CURLOPT_POSTFIELDSIZE_LARGE</code>.</p>
</div><h4 id='method.httppost' class='method'><span id='httppost.v' class='invisible'><code>fn <a href='#method.httppost' class='fnname'>httppost</a>(&amp;mut self, form: <a class='struct' href='../../curl/easy/struct.Form.html' title='curl::easy::Form'>Form</a>) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt;</code></span></h4>
<div class='docblock'><p>Tells libcurl you want a multipart/formdata HTTP POST to be made and you
instruct what data to pass on to the server in the <code>form</code> argument.</p>

<p>By default this option is set to null and corresponds to
<code>CURLOPT_HTTPPOST</code>.</p>
</div><h4 id='method.referer' class='method'><span id='referer.v' class='invisible'><code>fn <a href='#method.referer' class='fnname'>referer</a>(&amp;mut self, referer: &amp;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.str.html'>str</a>) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt;</code></span></h4>
<div class='docblock'><p>Sets the HTTP referer header</p>

<p>By default this option is not set and corresponds to <code>CURLOPT_REFERER</code>.</p>
</div><h4 id='method.useragent' class='method'><span id='useragent.v' class='invisible'><code>fn <a href='#method.useragent' class='fnname'>useragent</a>(&amp;mut self, useragent: &amp;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.str.html'>str</a>) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt;</code></span></h4>
<div class='docblock'><p>Sets the HTTP user-agent header</p>

<p>By default this option is not set and corresponds to
<code>CURLOPT_USERAGENT</code>.</p>
</div><h4 id='method.http_headers' class='method'><span id='http_headers.v' class='invisible'><code>fn <a href='#method.http_headers' class='fnname'>http_headers</a>(&amp;mut self, list: <a class='struct' href='../../curl/easy/struct.List.html' title='curl::easy::List'>List</a>) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt;</code></span></h4>
<div class='docblock'><p>Add some headers to this HTTP request.</p>

<p>If you add a header that is otherwise used internally, the value here
takes precedence. If a header is added with no content (like <code>Accept:</code>)
the internally the header will get disabled. To add a header with no
content, use the form <code>MyHeader;</code> (not the trailing semicolon).</p>

<p>Headers must not be CRLF terminated. Many replaced headers have common
shortcuts which should be prefered.</p>

<p>By default this option is not set and corresponds to
<code>CURLOPT_HTTPHEADER</code></p>

<h1 id='examples-4' class='section-header'><a href='#examples-4'>Examples</a></h1>
<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>curl</span>::<span class='ident'>easy</span>::{<span class='ident'>Easy</span>, <span class='ident'>List</span>};

<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>list</span> <span class='op'>=</span> <span class='ident'>List</span>::<span class='ident'>new</span>();
<span class='ident'>list</span>.<span class='ident'>append</span>(<span class='string'>&quot;Foo: bar&quot;</span>).<span class='ident'>unwrap</span>();
<span class='ident'>list</span>.<span class='ident'>append</span>(<span class='string'>&quot;Bar: baz&quot;</span>).<span class='ident'>unwrap</span>();

<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>handle</span> <span class='op'>=</span> <span class='ident'>Easy</span>::<span class='ident'>new</span>();
<span class='ident'>handle</span>.<span class='ident'>url</span>(<span class='string'>&quot;https://www.rust-lang.org/&quot;</span>).<span class='ident'>unwrap</span>();
<span class='ident'>handle</span>.<span class='ident'>http_headers</span>(<span class='ident'>list</span>).<span class='ident'>unwrap</span>();
<span class='ident'>handle</span>.<span class='ident'>perform</span>().<span class='ident'>unwrap</span>();</pre>
</div><h4 id='method.cookie' class='method'><span id='cookie.v' class='invisible'><code>fn <a href='#method.cookie' class='fnname'>cookie</a>(&amp;mut self, cookie: &amp;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.str.html'>str</a>) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt;</code></span></h4>
<div class='docblock'><p>Set the contents of the HTTP Cookie header.</p>

<p>Pass a string of the form <code>name=contents</code> for one cookie value or
<code>name1=val1; name2=val2</code> for multiple values.</p>

<p>Using this option multiple times will only make the latest string
override the previous ones. This option will not enable the cookie
engine, use <code>cookie_file</code> or <code>cookie_jar</code> to do that.</p>

<p>By default this option is not set and corresponds to <code>CURLOPT_COOKIE</code>.</p>
</div><h4 id='method.cookie_file' class='method'><span id='cookie_file.v' class='invisible'><code>fn <a href='#method.cookie_file' class='fnname'>cookie_file</a>&lt;P:&nbsp;<a class='trait' href='https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html' title='core::convert::AsRef'>AsRef</a>&lt;<a class='struct' href='https://doc.rust-lang.org/nightly/std/path/struct.Path.html' title='std::path::Path'>Path</a>&gt;&gt;(&amp;mut self, file: P) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt;</code></span></h4>
<div class='docblock'><p>Set the file name to read cookies from.</p>

<p>The cookie data can be in either the old Netscape / Mozilla cookie data
format or just regular HTTP headers (Set-Cookie style) dumped to a file.</p>

<p>This also enables the cookie engine, making libcurl parse and send
cookies on subsequent requests with this handle.</p>

<p>Given an empty or non-existing file or by passing the empty string (&quot;&quot;)
to this option, you can enable the cookie engine without reading any
initial cookies.</p>

<p>If you use this option multiple times, you just add more files to read.
Subsequent files will add more cookies.</p>

<p>By default this option is not set and corresponds to
<code>CURLOPT_COOKIEFILE</code>.</p>
</div><h4 id='method.cookie_jar' class='method'><span id='cookie_jar.v' class='invisible'><code>fn <a href='#method.cookie_jar' class='fnname'>cookie_jar</a>&lt;P:&nbsp;<a class='trait' href='https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html' title='core::convert::AsRef'>AsRef</a>&lt;<a class='struct' href='https://doc.rust-lang.org/nightly/std/path/struct.Path.html' title='std::path::Path'>Path</a>&gt;&gt;(&amp;mut self, file: P) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt;</code></span></h4>
<div class='docblock'><p>Set the file name to store cookies to.</p>

<p>This will make libcurl write all internally known cookies to the file
when this handle is dropped. If no cookies are known, no file will be
created. Specify &quot;-&quot; as filename to instead have the cookies written to
stdout. Using this option also enables cookies for this session, so if
you for example follow a location it will make matching cookies get sent
accordingly.</p>

<p>Note that libcurl doesn&#39;t read any cookies from the cookie jar. If you
want to read cookies from a file, use <code>cookie_file</code>.</p>

<p>By default this option is not set and corresponds to
<code>CURLOPT_COOKIEJAR</code>.</p>
</div><h4 id='method.cookie_session' class='method'><span id='cookie_session.v' class='invisible'><code>fn <a href='#method.cookie_session' class='fnname'>cookie_session</a>(&amp;mut self, session: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a>) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt;</code></span></h4>
<div class='docblock'><p>Start a new cookie session</p>

<p>Marks this as a new cookie &quot;session&quot;. It will force libcurl to ignore
all cookies it is about to load that are &quot;session cookies&quot; from the
previous session. By default, libcurl always stores and loads all
cookies, independent if they are session cookies or not. Session cookies
are cookies without expiry date and they are meant to be alive and
existing for this &quot;session&quot; only.</p>

<p>By default this option is <code>false</code> and corresponds to
<code>CURLOPT_COOKIESESSION</code>.</p>
</div><h4 id='method.cookie_list' class='method'><span id='cookie_list.v' class='invisible'><code>fn <a href='#method.cookie_list' class='fnname'>cookie_list</a>(&amp;mut self, cookie: &amp;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.str.html'>str</a>) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt;</code></span></h4>
<div class='docblock'><p>Add to or manipulate cookies held in memory.</p>

<p>Such a cookie can be either a single line in Netscape / Mozilla format
or just regular HTTP-style header (Set-Cookie: ...) format. This will
also enable the cookie engine. This adds that single cookie to the
internal cookie store.</p>

<p>Exercise caution if you are using this option and multiple transfers may
occur. If you use the Set-Cookie format and don&#39;t specify a domain then
the cookie is sent for any domain (even after redirects are followed)
and cannot be modified by a server-set cookie. If a server sets a cookie
of the same name (or maybe you&#39;ve imported one) then both will be sent
on a future transfer to that server, likely not what you intended.
address these issues set a domain in Set-Cookie or use the Netscape
format.</p>

<p>Additionally, there are commands available that perform actions if you
pass in these exact strings:</p>

<ul>
<li>&quot;ALL&quot; - erases all cookies held in memory</li>
<li>&quot;SESS&quot; - erases all session cookies held in memory</li>
<li>&quot;FLUSH&quot; - write all known cookies to the specified cookie jar</li>
<li>&quot;RELOAD&quot; - reread all cookies from the cookie file</li>
</ul>

<p>By default this options corresponds to <code>CURLOPT_COOKIELIST</code></p>
</div><h4 id='method.get' class='method'><span id='get.v' class='invisible'><code>fn <a href='#method.get' class='fnname'>get</a>(&amp;mut self, enable: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a>) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt;</code></span></h4>
<div class='docblock'><p>Ask for a HTTP GET request.</p>

<p>By default this option is <code>false</code> and corresponds to <code>CURLOPT_HTTPGET</code>.</p>
</div><h4 id='method.ignore_content_length' class='method'><span id='ignore_content_length.v' class='invisible'><code>fn <a href='#method.ignore_content_length' class='fnname'>ignore_content_length</a>(&amp;mut self, ignore: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a>) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt;</code></span></h4>
<div class='docblock'><p>Ignore the content-length header.</p>

<p>By default this option is <code>false</code> and corresponds to
<code>CURLOPT_IGNORE_CONTENT_LENGTH</code>.</p>
</div><h4 id='method.http_content_decoding' class='method'><span id='http_content_decoding.v' class='invisible'><code>fn <a href='#method.http_content_decoding' class='fnname'>http_content_decoding</a>(&amp;mut self, enable: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a>) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt;</code></span></h4>
<div class='docblock'><p>Enable or disable HTTP content decoding.</p>

<p>By default this option is <code>true</code> and corresponds to
<code>CURLOPT_HTTP_CONTENT_DECODING</code>.</p>
</div><h4 id='method.http_transfer_decoding' class='method'><span id='http_transfer_decoding.v' class='invisible'><code>fn <a href='#method.http_transfer_decoding' class='fnname'>http_transfer_decoding</a>(&amp;mut self, enable: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a>) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt;</code></span></h4>
<div class='docblock'><p>Enable or disable HTTP transfer decoding.</p>

<p>By default this option is <code>true</code> and corresponds to
<code>CURLOPT_HTTP_TRANSFER_DECODING</code>.</p>
</div><h4 id='method.range' class='method'><span id='range.v' class='invisible'><code>fn <a href='#method.range' class='fnname'>range</a>(&amp;mut self, range: &amp;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.str.html'>str</a>) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt;</code></span></h4>
<div class='docblock'><p>Indicates the range that this request should retrieve.</p>

<p>The string provided should be of the form <code>N-M</code> where either <code>N</code> or <code>M</code>
can be left out. For HTTP transfers multiple ranges separated by commas
are also accepted.</p>

<p>By default this option is not set and corresponds to <code>CURLOPT_RANGE</code>.</p>
</div><h4 id='method.resume_from' class='method'><span id='resume_from.v' class='invisible'><code>fn <a href='#method.resume_from' class='fnname'>resume_from</a>(&amp;mut self, from: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.u64.html'>u64</a>) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt;</code></span></h4>
<div class='docblock'><p>Set a point to resume transfer from</p>

<p>Specify the offset in bytes you want the transfer to start from.</p>

<p>By default this option is 0 and corresponds to
<code>CURLOPT_RESUME_FROM_LARGE</code>.</p>
</div><h4 id='method.custom_request' class='method'><span id='custom_request.v' class='invisible'><code>fn <a href='#method.custom_request' class='fnname'>custom_request</a>(&amp;mut self, request: &amp;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.str.html'>str</a>) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt;</code></span></h4>
<div class='docblock'><p>Set a custom request string</p>

<p>Specifies that a custom request will be made (e.g. a custom HTTP
method). This does not change how libcurl performs internally, just
changes the string sent to the server.</p>

<p>By default this option is not set and corresponds to
<code>CURLOPT_CUSTOMREQUEST</code>.</p>
</div><h4 id='method.fetch_filetime' class='method'><span id='fetch_filetime.v' class='invisible'><code>fn <a href='#method.fetch_filetime' class='fnname'>fetch_filetime</a>(&amp;mut self, fetch: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a>) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt;</code></span></h4>
<div class='docblock'><p>Get the modification time of the remote resource</p>

<p>If true, libcurl will attempt to get the modification time of the
remote document in this operation. This requires that the remote server
sends the time or replies to a time querying command. The <code>filetime</code>
function can be used after a transfer to extract the received time (if
any).</p>

<p>By default this option is <code>false</code> and corresponds to <code>CURLOPT_FILETIME</code></p>
</div><h4 id='method.nobody' class='method'><span id='nobody.v' class='invisible'><code>fn <a href='#method.nobody' class='fnname'>nobody</a>(&amp;mut self, enable: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a>) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt;</code></span></h4>
<div class='docblock'><p>Indicate whether to download the request without getting the body</p>

<p>This is useful, for example, for doing a HEAD request.</p>

<p>By default this option is <code>false</code> and corresponds to <code>CURLOPT_NOBODY</code>.</p>
</div><h4 id='method.in_filesize' class='method'><span id='in_filesize.v' class='invisible'><code>fn <a href='#method.in_filesize' class='fnname'>in_filesize</a>(&amp;mut self, size: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.u64.html'>u64</a>) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt;</code></span></h4>
<div class='docblock'><p>Set the size of the input file to send off.</p>

<p>By default this option is not set and corresponds to
<code>CURLOPT_INFILESIZE_LARGE</code>.</p>
</div><h4 id='method.upload' class='method'><span id='upload.v' class='invisible'><code>fn <a href='#method.upload' class='fnname'>upload</a>(&amp;mut self, enable: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a>) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt;</code></span></h4>
<div class='docblock'><p>Enable or disable data upload.</p>

<p>This means that a PUT request will be made for HTTP and probably wants
to be combined with the read callback as well as the <code>in_filesize</code>
method.</p>

<p>By default this option is <code>false</code> and corresponds to <code>CURLOPT_UPLOAD</code>.</p>
</div><h4 id='method.max_filesize' class='method'><span id='max_filesize.v' class='invisible'><code>fn <a href='#method.max_filesize' class='fnname'>max_filesize</a>(&amp;mut self, size: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.u64.html'>u64</a>) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt;</code></span></h4>
<div class='docblock'><p>Configure the maximum file size to download.</p>

<p>By default this option is not set and corresponds to
<code>CURLOPT_MAXFILESIZE_LARGE</code>.</p>
</div><h4 id='method.time_condition' class='method'><span id='time_condition.v' class='invisible'><code>fn <a href='#method.time_condition' class='fnname'>time_condition</a>(&amp;mut self, cond: <a class='enum' href='../../curl/easy/enum.TimeCondition.html' title='curl::easy::TimeCondition'>TimeCondition</a>) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt;</code></span></h4>
<div class='docblock'><p>Selects a condition for a time request.</p>

<p>This value indicates how the <code>time_value</code> option is interpreted.</p>

<p>By default this option is not set and corresponds to
<code>CURLOPT_TIMECONDITION</code>.</p>
</div><h4 id='method.time_value' class='method'><span id='time_value.v' class='invisible'><code>fn <a href='#method.time_value' class='fnname'>time_value</a>(&amp;mut self, val: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.i64.html'>i64</a>) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt;</code></span></h4>
<div class='docblock'><p>Sets the time value for a conditional request.</p>

<p>The value here should be the number of seconds elapsed since January 1,
1970. To pass how to interpret this value, use <code>time_condition</code>.</p>

<p>By default this option is not set and corresponds to
<code>CURLOPT_TIMEVALUE</code>.</p>
</div><h4 id='method.timeout' class='method'><span id='timeout.v' class='invisible'><code>fn <a href='#method.timeout' class='fnname'>timeout</a>(&amp;mut self, timeout: <a class='struct' href='https://doc.rust-lang.org/nightly/std/time/duration/struct.Duration.html' title='std::time::duration::Duration'>Duration</a>) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt;</code></span></h4>
<div class='docblock'><p>Set maximum time the request is allowed to take.</p>

<p>Normally, name lookups can take a considerable time and limiting
operations to less than a few minutes risk aborting perfectly normal
operations.</p>

<p>If libcurl is built to use the standard system name resolver, that
portion of the transfer will still use full-second resolution for
timeouts with a minimum timeout allowed of one second.</p>

<p>In unix-like systems, this might cause signals to be used unless
<code>nosignal</code> is set.</p>

<p>Since this puts a hard limit for how long time a request is allowed to
take, it has limited use in dynamic use cases with varying transfer
times. You are then advised to explore <code>low_speed_limit</code>,
<code>low_speed_time</code> or using <code>progress_function</code> to implement your own
timeout logic.</p>

<p>By default this option is not set and corresponds to
<code>CURLOPT_TIMEOUT_MS</code>.</p>
</div><h4 id='method.low_speed_limit' class='method'><span id='low_speed_limit.v' class='invisible'><code>fn <a href='#method.low_speed_limit' class='fnname'>low_speed_limit</a>(&amp;mut self, limit: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.u32.html'>u32</a>) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt;</code></span></h4>
<div class='docblock'><p>Set the low speed limit in bytes per second.</p>

<p>This specifies the average transfer speed in bytes per second that the
transfer should be below during <code>low_speed_time</code> for libcurl to consider
it to be too slow and abort.</p>

<p>By default this option is not set and corresponds to
<code>CURLOPT_LOW_SPEED_LIMIT</code>.</p>
</div><h4 id='method.low_speed_time' class='method'><span id='low_speed_time.v' class='invisible'><code>fn <a href='#method.low_speed_time' class='fnname'>low_speed_time</a>(&amp;mut self, dur: <a class='struct' href='https://doc.rust-lang.org/nightly/std/time/duration/struct.Duration.html' title='std::time::duration::Duration'>Duration</a>) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt;</code></span></h4>
<div class='docblock'><p>Set the low speed time period.</p>

<p>Specifies the window of time for which if the transfer rate is below
<code>low_speed_limit</code> the request will be aborted.</p>

<p>By default this option is not set and corresponds to
<code>CURLOPT_LOW_SPEED_TIME</code>.</p>
</div><h4 id='method.max_send_speed' class='method'><span id='max_send_speed.v' class='invisible'><code>fn <a href='#method.max_send_speed' class='fnname'>max_send_speed</a>(&amp;mut self, speed: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.u64.html'>u64</a>) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt;</code></span></h4>
<div class='docblock'><p>Rate limit data upload speed</p>

<p>If an upload exceeds this speed (counted in bytes per second) on
cumulative average during the transfer, the transfer will pause to keep
the average rate less than or equal to the parameter value.</p>

<p>By default this option is not set (unlimited speed) and corresponds to
<code>CURLOPT_MAX_SEND_SPEED_LARGE</code>.</p>
</div><h4 id='method.max_recv_speed' class='method'><span id='max_recv_speed.v' class='invisible'><code>fn <a href='#method.max_recv_speed' class='fnname'>max_recv_speed</a>(&amp;mut self, speed: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.u64.html'>u64</a>) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt;</code></span></h4>
<div class='docblock'><p>Rate limit data download speed</p>

<p>If a download exceeds this speed (counted in bytes per second) on
cumulative average during the transfer, the transfer will pause to keep
the average rate less than or equal to the parameter value.</p>

<p>By default this option is not set (unlimited speed) and corresponds to
<code>CURLOPT_MAX_RECV_SPEED_LARGE</code>.</p>
</div><h4 id='method.max_connects' class='method'><span id='max_connects.v' class='invisible'><code>fn <a href='#method.max_connects' class='fnname'>max_connects</a>(&amp;mut self, max: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.u32.html'>u32</a>) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt;</code></span></h4>
<div class='docblock'><p>Set the maximum connection cache size.</p>

<p>The set amount will be the maximum number of simultaneously open
persistent connections that libcurl may cache in the pool associated
with this handle. The default is 5, and there isn&#39;t much point in
changing this value unless you are perfectly aware of how this works and
changes libcurl&#39;s behaviour. This concerns connections using any of the
protocols that support persistent connections.</p>

<p>When reaching the maximum limit, curl closes the oldest one in the cache
to prevent increasing the number of open connections.</p>

<p>By default this option is set to 5 and corresponds to
<code>CURLOPT_MAXCONNECTS</code></p>
</div><h4 id='method.fresh_connect' class='method'><span id='fresh_connect.v' class='invisible'><code>fn <a href='#method.fresh_connect' class='fnname'>fresh_connect</a>(&amp;mut self, enable: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a>) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt;</code></span></h4>
<div class='docblock'><p>Force a new connection to be used.</p>

<p>Makes the next transfer use a new (fresh) connection by force instead of
trying to re-use an existing one. This option should be used with
caution and only if you understand what it does as it may seriously
impact performance.</p>

<p>By default this option is <code>false</code> and corresponds to
<code>CURLOPT_FRESH_CONNECT</code>.</p>
</div><h4 id='method.forbid_reuse' class='method'><span id='forbid_reuse.v' class='invisible'><code>fn <a href='#method.forbid_reuse' class='fnname'>forbid_reuse</a>(&amp;mut self, enable: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a>) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt;</code></span></h4>
<div class='docblock'><p>Make connection get closed at once after use.</p>

<p>Makes libcurl explicitly close the connection when done with the
transfer. Normally, libcurl keeps all connections alive when done with
one transfer in case a succeeding one follows that can re-use them.
This option should be used with caution and only if you understand what
it does as it can seriously impact performance.</p>

<p>By default this option is <code>false</code> and corresponds to
<code>CURLOPT_FORBID_REUSE</code>.</p>
</div><h4 id='method.connect_timeout' class='method'><span id='connect_timeout.v' class='invisible'><code>fn <a href='#method.connect_timeout' class='fnname'>connect_timeout</a>(&amp;mut self, timeout: <a class='struct' href='https://doc.rust-lang.org/nightly/std/time/duration/struct.Duration.html' title='std::time::duration::Duration'>Duration</a>) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt;</code></span></h4>
<div class='docblock'><p>Timeout for the connect phase</p>

<p>This is the maximum time that you allow the connection phase to the
server to take. This only limits the connection phase, it has no impact
once it has connected.</p>

<p>By default this value is 300 seconds and corresponds to
<code>CURLOPT_CONNECTTIMEOUT_MS</code>.</p>
</div><h4 id='method.ip_resolve' class='method'><span id='ip_resolve.v' class='invisible'><code>fn <a href='#method.ip_resolve' class='fnname'>ip_resolve</a>(&amp;mut self, resolve: <a class='enum' href='../../curl/easy/enum.IpResolve.html' title='curl::easy::IpResolve'>IpResolve</a>) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt;</code></span></h4>
<div class='docblock'><p>Specify which IP protocol version to use</p>

<p>Allows an application to select what kind of IP addresses to use when
resolving host names. This is only interesting when using host names
that resolve addresses using more than one version of IP.</p>

<p>By default this value is &quot;any&quot; and corresponds to <code>CURLOPT_IPRESOLVE</code>.</p>
</div><h4 id='method.connect_only' class='method'><span id='connect_only.v' class='invisible'><code>fn <a href='#method.connect_only' class='fnname'>connect_only</a>(&amp;mut self, enable: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a>) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt;</code></span></h4>
<div class='docblock'><p>Configure whether to stop when connected to target server</p>

<p>When enabled it tells the library to perform all the required proxy
authentication and connection setup, but no data transfer, and then
return.</p>

<p>The option can be used to simply test a connection to a server.</p>

<p>By default this value is <code>false</code> and corresponds to
<code>CURLOPT_CONNECT_ONLY</code>.</p>
</div><h4 id='method.ssl_cert' class='method'><span id='ssl_cert.v' class='invisible'><code>fn <a href='#method.ssl_cert' class='fnname'>ssl_cert</a>&lt;P:&nbsp;<a class='trait' href='https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html' title='core::convert::AsRef'>AsRef</a>&lt;<a class='struct' href='https://doc.rust-lang.org/nightly/std/path/struct.Path.html' title='std::path::Path'>Path</a>&gt;&gt;(&amp;mut self, cert: P) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt;</code></span></h4>
<div class='docblock'><p>Sets the SSL client certificate.</p>

<p>The string should be the file name of your client certificate. The
default format is &quot;P12&quot; on Secure Transport and &quot;PEM&quot; on other engines,
and can be changed with <code>ssl_cert_type</code>.</p>

<p>With NSS or Secure Transport, this can also be the nickname of the
certificate you wish to authenticate with as it is named in the security
database. If you want to use a file from the current directory, please
precede it with &quot;./&quot; prefix, in order to avoid confusion with a
nickname.</p>

<p>When using a client certificate, you most likely also need to provide a
private key with <code>ssl_key</code>.</p>

<p>By default this option is not set and corresponds to <code>CURLOPT_SSLCERT</code>.</p>
</div><h4 id='method.ssl_cert_type' class='method'><span id='ssl_cert_type.v' class='invisible'><code>fn <a href='#method.ssl_cert_type' class='fnname'>ssl_cert_type</a>(&amp;mut self, kind: &amp;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.str.html'>str</a>) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt;</code></span></h4>
<div class='docblock'><p>Specify type of the client SSL certificate.</p>

<p>The string should be the format of your certificate. Supported formats
are &quot;PEM&quot; and &quot;DER&quot;, except with Secure Transport. OpenSSL (versions
0.9.3 and later) and Secure Transport (on iOS 5 or later, or OS X 10.7
or later) also support &quot;P12&quot; for PKCS#12-encoded files.</p>

<p>By default this option is &quot;PEM&quot; and corresponds to
<code>CURLOPT_SSLCERTTYPE</code>.</p>
</div><h4 id='method.ssl_key' class='method'><span id='ssl_key.v' class='invisible'><code>fn <a href='#method.ssl_key' class='fnname'>ssl_key</a>&lt;P:&nbsp;<a class='trait' href='https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html' title='core::convert::AsRef'>AsRef</a>&lt;<a class='struct' href='https://doc.rust-lang.org/nightly/std/path/struct.Path.html' title='std::path::Path'>Path</a>&gt;&gt;(&amp;mut self, key: P) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt;</code></span></h4>
<div class='docblock'><p>Specify private keyfile for TLS and SSL client cert.</p>

<p>The string should be the file name of your private key. The default
format is &quot;PEM&quot; and can be changed with <code>ssl_key_type</code>.</p>

<p>(iOS and Mac OS X only) This option is ignored if curl was built against
Secure Transport. Secure Transport expects the private key to be already
present in the keychain or PKCS#12 file containing the certificate.</p>

<p>By default this option is not set and corresponds to <code>CURLOPT_SSLKEY</code>.</p>
</div><h4 id='method.ssl_key_type' class='method'><span id='ssl_key_type.v' class='invisible'><code>fn <a href='#method.ssl_key_type' class='fnname'>ssl_key_type</a>(&amp;mut self, kind: &amp;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.str.html'>str</a>) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt;</code></span></h4>
<div class='docblock'><p>Set type of the private key file.</p>

<p>The string should be the format of your private key. Supported formats
are &quot;PEM&quot;, &quot;DER&quot; and &quot;ENG&quot;.</p>

<p>The format &quot;ENG&quot; enables you to load the private key from a crypto
engine. In this case <code>ssl_key</code> is used as an identifier passed to
the engine. You have to set the crypto engine with <code>ssl_engine</code>.
&quot;DER&quot; format key file currently does not work because of a bug in
OpenSSL.</p>

<p>By default this option is &quot;PEM&quot; and corresponds to
<code>CURLOPT_SSLKEYTYPE</code>.</p>
</div><h4 id='method.key_password' class='method'><span id='key_password.v' class='invisible'><code>fn <a href='#method.key_password' class='fnname'>key_password</a>(&amp;mut self, password: &amp;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.str.html'>str</a>) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt;</code></span></h4>
<div class='docblock'><p>Set passphrase to private key.</p>

<p>This will be used as the password required to use the <code>ssl_key</code>.
You never needed a pass phrase to load a certificate but you need one to
load your private key.</p>

<p>By default this option is not set and corresponds to
<code>CURLOPT_KEYPASSWD</code>.</p>
</div><h4 id='method.ssl_engine' class='method'><span id='ssl_engine.v' class='invisible'><code>fn <a href='#method.ssl_engine' class='fnname'>ssl_engine</a>(&amp;mut self, engine: &amp;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.str.html'>str</a>) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt;</code></span></h4>
<div class='docblock'><p>Set the SSL engine identifier.</p>

<p>This will be used as the identifier for the crypto engine you want to
use for your private key.</p>

<p>By default this option is not set and corresponds to
<code>CURLOPT_SSLENGINE</code>.</p>
</div><h4 id='method.ssl_engine_default' class='method'><span id='ssl_engine_default.v' class='invisible'><code>fn <a href='#method.ssl_engine_default' class='fnname'>ssl_engine_default</a>(&amp;mut self, enable: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a>) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt;</code></span></h4>
<div class='docblock'><p>Make this handle&#39;s SSL engine the default.</p>

<p>By default this option is not set and corresponds to
<code>CURLOPT_SSLENGINE_DEFAULT</code>.</p>
</div><h4 id='method.ssl_version' class='method'><span id='ssl_version.v' class='invisible'><code>fn <a href='#method.ssl_version' class='fnname'>ssl_version</a>(&amp;mut self, version: <a class='enum' href='../../curl/easy/enum.SslVersion.html' title='curl::easy::SslVersion'>SslVersion</a>) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt;</code></span></h4>
<div class='docblock'><p>Set preferred TLS/SSL version.</p>

<p>By default this option is not set and corresponds to
<code>CURLOPT_SSLVERSION</code>.</p>
</div><h4 id='method.ssl_verify_host' class='method'><span id='ssl_verify_host.v' class='invisible'><code>fn <a href='#method.ssl_verify_host' class='fnname'>ssl_verify_host</a>(&amp;mut self, verify: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a>) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt;</code></span></h4>
<div class='docblock'><p>Verify the certificate&#39;s name against host.</p>

<p>This should be disabled with great caution! It basically disables the
security features of SSL if it is disabled.</p>

<p>By default this option is set to <code>true</code> and corresponds to
<code>CURLOPT_SSL_VERIFYHOST</code>.</p>
</div><h4 id='method.ssl_verify_peer' class='method'><span id='ssl_verify_peer.v' class='invisible'><code>fn <a href='#method.ssl_verify_peer' class='fnname'>ssl_verify_peer</a>(&amp;mut self, verify: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a>) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt;</code></span></h4>
<div class='docblock'><p>Verify the peer&#39;s SSL certificate.</p>

<p>This should be disabled with great caution! It basically disables the
security features of SSL if it is disabled.</p>

<p>By default this option is set to <code>true</code> and corresponds to
<code>CURLOPT_SSL_VERIFYPEER</code>.</p>
</div><h4 id='method.cainfo' class='method'><span id='cainfo.v' class='invisible'><code>fn <a href='#method.cainfo' class='fnname'>cainfo</a>&lt;P:&nbsp;<a class='trait' href='https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html' title='core::convert::AsRef'>AsRef</a>&lt;<a class='struct' href='https://doc.rust-lang.org/nightly/std/path/struct.Path.html' title='std::path::Path'>Path</a>&gt;&gt;(&amp;mut self, path: P) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt;</code></span></h4>
<div class='docblock'><p>Specify the path to Certificate Authority (CA) bundle</p>

<p>The file referenced should hold one or more certificates to verify the
peer with.</p>

<p>This option is by default set to the system path where libcurl&#39;s cacert
bundle is assumed to be stored, as established at build time.</p>

<p>If curl is built against the NSS SSL library, the NSS PEM PKCS#11 module
(libnsspem.so) needs to be available for this option to work properly.</p>

<p>By default this option is the system defaults, and corresponds to
<code>CURLOPT_CAINFO</code>.</p>
</div><h4 id='method.issuer_cert' class='method'><span id='issuer_cert.v' class='invisible'><code>fn <a href='#method.issuer_cert' class='fnname'>issuer_cert</a>&lt;P:&nbsp;<a class='trait' href='https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html' title='core::convert::AsRef'>AsRef</a>&lt;<a class='struct' href='https://doc.rust-lang.org/nightly/std/path/struct.Path.html' title='std::path::Path'>Path</a>&gt;&gt;(&amp;mut self, path: P) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt;</code></span></h4>
<div class='docblock'><p>Set the issuer SSL certificate filename</p>

<p>Specifies a file holding a CA certificate in PEM format. If the option
is set, an additional check against the peer certificate is performed to
verify the issuer is indeed the one associated with the certificate
provided by the option. This additional check is useful in multi-level
PKI where one needs to enforce that the peer certificate is from a
specific branch of the tree.</p>

<p>This option makes sense only when used in combination with the
<code>ssl_verify_peer</code> option. Otherwise, the result of the check is not
considered as failure.</p>

<p>By default this option is not set and corresponds to
<code>CURLOPT_ISSUERCERT</code>.</p>
</div><h4 id='method.capath' class='method'><span id='capath.v' class='invisible'><code>fn <a href='#method.capath' class='fnname'>capath</a>&lt;P:&nbsp;<a class='trait' href='https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html' title='core::convert::AsRef'>AsRef</a>&lt;<a class='struct' href='https://doc.rust-lang.org/nightly/std/path/struct.Path.html' title='std::path::Path'>Path</a>&gt;&gt;(&amp;mut self, path: P) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt;</code></span></h4>
<div class='docblock'><p>Specify directory holding CA certificates</p>

<p>Names a directory holding multiple CA certificates to verify the peer
with. If libcurl is built against OpenSSL, the certificate directory
must be prepared using the openssl c_rehash utility. This makes sense
only when used in combination with the <code>ssl_verify_peer</code> option.</p>

<p>By default this option is not set and corresponds to <code>CURLOPT_CAPATH</code>.</p>
</div><h4 id='method.crlfile' class='method'><span id='crlfile.v' class='invisible'><code>fn <a href='#method.crlfile' class='fnname'>crlfile</a>&lt;P:&nbsp;<a class='trait' href='https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html' title='core::convert::AsRef'>AsRef</a>&lt;<a class='struct' href='https://doc.rust-lang.org/nightly/std/path/struct.Path.html' title='std::path::Path'>Path</a>&gt;&gt;(&amp;mut self, path: P) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt;</code></span></h4>
<div class='docblock'><p>Specify a Certificate Revocation List file</p>

<p>Names a file with the concatenation of CRL (in PEM format) to use in the
certificate validation that occurs during the SSL exchange.</p>

<p>When curl is built to use NSS or GnuTLS, there is no way to influence
the use of CRL passed to help in the verification process. When libcurl
is built with OpenSSL support, X509_V_FLAG_CRL_CHECK and
X509_V_FLAG_CRL_CHECK_ALL are both set, requiring CRL check against all
the elements of the certificate chain if a CRL file is passed.</p>

<p>This option makes sense only when used in combination with the
<code>ssl_verify_peer</code> option.</p>

<p>A specific error code (<code>is_ssl_crl_badfile</code>) is defined with the
option. It is returned when the SSL exchange fails because the CRL file
cannot be loaded. A failure in certificate verification due to a
revocation information found in the CRL does not trigger this specific
error.</p>

<p>By default this option is not set and corresponds to <code>CURLOPT_CRLFILE</code>.</p>
</div><h4 id='method.certinfo' class='method'><span id='certinfo.v' class='invisible'><code>fn <a href='#method.certinfo' class='fnname'>certinfo</a>(&amp;mut self, enable: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a>) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt;</code></span></h4>
<div class='docblock'><p>Request SSL certificate information</p>

<p>Enable libcurl&#39;s certificate chain info gatherer. With this enabled,
libcurl will extract lots of information and data about the certificates
in the certificate chain used in the SSL connection.</p>

<p>By default this option is <code>false</code> and corresponds to
<code>CURLOPT_CERTINFO</code>.</p>
</div><h4 id='method.random_file' class='method'><span id='random_file.v' class='invisible'><code>fn <a href='#method.random_file' class='fnname'>random_file</a>&lt;P:&nbsp;<a class='trait' href='https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html' title='core::convert::AsRef'>AsRef</a>&lt;<a class='struct' href='https://doc.rust-lang.org/nightly/std/path/struct.Path.html' title='std::path::Path'>Path</a>&gt;&gt;(&amp;mut self, p: P) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt;</code></span></h4>
<div class='docblock'><p>Specify a source for random data</p>

<p>The file will be used to read from to seed the random engine for SSL and
more.</p>

<p>By default this option is not set and corresponds to
<code>CURLOPT_RANDOM_FILE</code>.</p>
</div><h4 id='method.egd_socket' class='method'><span id='egd_socket.v' class='invisible'><code>fn <a href='#method.egd_socket' class='fnname'>egd_socket</a>&lt;P:&nbsp;<a class='trait' href='https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html' title='core::convert::AsRef'>AsRef</a>&lt;<a class='struct' href='https://doc.rust-lang.org/nightly/std/path/struct.Path.html' title='std::path::Path'>Path</a>&gt;&gt;(&amp;mut self, p: P) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt;</code></span></h4>
<div class='docblock'><p>Specify EGD socket path.</p>

<p>Indicates the path name to the Entropy Gathering Daemon socket. It will
be used to seed the random engine for SSL.</p>

<p>By default this option is not set and corresponds to
<code>CURLOPT_EGDSOCKET</code>.</p>
</div><h4 id='method.ssl_cipher_list' class='method'><span id='ssl_cipher_list.v' class='invisible'><code>fn <a href='#method.ssl_cipher_list' class='fnname'>ssl_cipher_list</a>(&amp;mut self, ciphers: &amp;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.str.html'>str</a>) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt;</code></span></h4>
<div class='docblock'><p>Specify ciphers to use for TLS.</p>

<p>Holds the list of ciphers to use for the SSL connection. The list must
be syntactically correct, it consists of one or more cipher strings
separated by colons. Commas or spaces are also acceptable separators
but colons are normally used, !, - and + can be used as operators.</p>

<p>For OpenSSL and GnuTLS valid examples of cipher lists include &#39;RC4-SHA&#39;,
´SHA1+DES´, &#39;TLSv1&#39; and &#39;DEFAULT&#39;. The default list is normally set when
you compile OpenSSL.</p>

<p>You&#39;ll find more details about cipher lists on this URL:</p>

<p><a href="https://www.openssl.org/docs/apps/ciphers.html">https://www.openssl.org/docs/apps/ciphers.html</a></p>

<p>For NSS, valid examples of cipher lists include &#39;rsa_rc4_128_md5&#39;,
´rsa_aes_128_sha´, etc. With NSS you don&#39;t add/remove ciphers. If one
uses this option then all known ciphers are disabled and only those
passed in are enabled.</p>

<p>You&#39;ll find more details about the NSS cipher lists on this URL:</p>

<p><a href="http://git.fedorahosted.org/cgit/mod_nss.git/plain/docs/mod_nss.html#Directives">http://git.fedorahosted.org/cgit/mod_nss.git/plain/docs/mod_nss.html#Directives</a></p>

<p>By default this option is not set and corresponds to
<code>CURLOPT_SSL_CIPHER_LIST</code>.</p>
</div><h4 id='method.ssl_sessionid_cache' class='method'><span id='ssl_sessionid_cache.v' class='invisible'><code>fn <a href='#method.ssl_sessionid_cache' class='fnname'>ssl_sessionid_cache</a>(&amp;mut self, enable: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a>) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt;</code></span></h4>
<div class='docblock'><p>Enable or disable use of the SSL session-ID cache</p>

<p>By default all transfers are done using the cache enabled. While nothing
ever should get hurt by attempting to reuse SSL session-IDs, there seem
to be or have been broken SSL implementations in the wild that may
require you to disable this in order for you to succeed.</p>

<p>This corresponds to the <code>CURLOPT_SSL_SESSIONID_CACHE</code> option.</p>
</div><h4 id='method.effective_url' class='method'><span id='effective_url.v' class='invisible'><code>fn <a href='#method.effective_url' class='fnname'>effective_url</a>(&amp;mut self) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='enum' href='https://doc.rust-lang.org/nightly/core/option/enum.Option.html' title='core::option::Option'>Option</a>&lt;&amp;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.str.html'>str</a>&gt;, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt;</code></span></h4>
<div class='docblock'><p>Get the last used URL</p>

<p>In cases when you&#39;ve asked libcurl to follow redirects, it may
not be the same value you set with <code>url</code>.</p>

<p>This methods corresponds to the <code>CURLINFO_EFFECTIVE_URL</code> option.</p>

<p>Returns <code>Ok(None)</code> if no effective url is listed or <code>Err</code> if an error
happens or the underlying bytes aren&#39;t valid utf-8.</p>
</div><h4 id='method.effective_url_bytes' class='method'><span id='effective_url_bytes.v' class='invisible'><code>fn <a href='#method.effective_url_bytes' class='fnname'>effective_url_bytes</a>(&amp;mut self) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='enum' href='https://doc.rust-lang.org/nightly/core/option/enum.Option.html' title='core::option::Option'>Option</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.slice.html'>&amp;[</a><a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.u8.html'>u8</a><a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.slice.html'>]</a>&gt;, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt;</code></span></h4>
<div class='docblock'><p>Get the last used URL, in bytes</p>

<p>In cases when you&#39;ve asked libcurl to follow redirects, it may
not be the same value you set with <code>url</code>.</p>

<p>This methods corresponds to the <code>CURLINFO_EFFECTIVE_URL</code> option.</p>

<p>Returns <code>Ok(None)</code> if no effective url is listed or <code>Err</code> if an error
happens or the underlying bytes aren&#39;t valid utf-8.</p>
</div><h4 id='method.response_code' class='method'><span id='response_code.v' class='invisible'><code>fn <a href='#method.response_code' class='fnname'>response_code</a>(&amp;mut self) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.u32.html'>u32</a>, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt;</code></span></h4>
<div class='docblock'><p>Get the last response code</p>

<p>The stored value will be zero if no server response code has been
received. Note that a proxy&#39;s CONNECT response should be read with
<code>http_connectcode</code> and not this.</p>

<p>Corresponds to <code>CURLINFO_RESPONSE_CODE</code> and returns an error if this
option is not supported.</p>
</div><h4 id='method.http_connectcode' class='method'><span id='http_connectcode.v' class='invisible'><code>fn <a href='#method.http_connectcode' class='fnname'>http_connectcode</a>(&amp;mut self) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.u32.html'>u32</a>, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt;</code></span></h4>
<div class='docblock'><p>Get the CONNECT response code</p>

<p>Returns the last received HTTP proxy response code to a CONNECT request.
The returned value will be zero if no such response code was available.</p>

<p>Corresponds to <code>CURLINFO_HTTP_CONNECTCODE</code> and returns an error if this
option is not supported.</p>
</div><h4 id='method.filetime' class='method'><span id='filetime.v' class='invisible'><code>fn <a href='#method.filetime' class='fnname'>filetime</a>(&amp;mut self) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='enum' href='https://doc.rust-lang.org/nightly/core/option/enum.Option.html' title='core::option::Option'>Option</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.i64.html'>i64</a>&gt;, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt;</code></span></h4>
<div class='docblock'><p>Get the remote time of the retrieved document</p>

<p>Returns the remote time of the retrieved document (in number of seconds
since 1 Jan 1970 in the GMT/UTC time zone). If you get <code>None</code>, it can be
because of many reasons (it might be unknown, the server might hide it
or the server doesn&#39;t support the command that tells document time etc)
and the time of the document is unknown.</p>

<p>Note that you must tell the server to collect this information before
the transfer is made, by using the <code>filetime</code> method to
or you will unconditionally get a <code>None</code> back.</p>

<p>This corresponds to <code>CURLINFO_FILETIME</code> and may return an error if the
option is not supported</p>
</div><h4 id='method.redirect_count' class='method'><span id='redirect_count.v' class='invisible'><code>fn <a href='#method.redirect_count' class='fnname'>redirect_count</a>(&amp;mut self) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.u32.html'>u32</a>, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt;</code></span></h4>
<div class='docblock'><p>Get the number of redirects</p>

<p>Corresponds to <code>CURLINFO_REDIRECT_COUNT</code> and may return an error if the
option isn&#39;t supported.</p>
</div><h4 id='method.redirect_url' class='method'><span id='redirect_url.v' class='invisible'><code>fn <a href='#method.redirect_url' class='fnname'>redirect_url</a>(&amp;mut self) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='enum' href='https://doc.rust-lang.org/nightly/core/option/enum.Option.html' title='core::option::Option'>Option</a>&lt;&amp;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.str.html'>str</a>&gt;, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt;</code></span></h4>
<div class='docblock'><p>Get the URL a redirect would go to</p>

<p>Returns the URL a redirect would take you to if you would enable
<code>follow_location</code>. This can come very handy if you think using the
built-in libcurl redirect logic isn&#39;t good enough for you but you would
still prefer to avoid implementing all the magic of figuring out the new
URL.</p>

<p>Corresponds to <code>CURLINFO_REDIRECT_URL</code> and may return an error if the
url isn&#39;t valid utf-8 or an error happens.</p>
</div><h4 id='method.redirect_url_bytes' class='method'><span id='redirect_url_bytes.v' class='invisible'><code>fn <a href='#method.redirect_url_bytes' class='fnname'>redirect_url_bytes</a>(&amp;mut self) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='enum' href='https://doc.rust-lang.org/nightly/core/option/enum.Option.html' title='core::option::Option'>Option</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.slice.html'>&amp;[</a><a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.u8.html'>u8</a><a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.slice.html'>]</a>&gt;, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt;</code></span></h4>
<div class='docblock'><p>Get the URL a redirect would go to, in bytes</p>

<p>Returns the URL a redirect would take you to if you would enable
<code>follow_location</code>. This can come very handy if you think using the
built-in libcurl redirect logic isn&#39;t good enough for you but you would
still prefer to avoid implementing all the magic of figuring out the new
URL.</p>

<p>Corresponds to <code>CURLINFO_REDIRECT_URL</code> and may return an error.</p>
</div><h4 id='method.header_size' class='method'><span id='header_size.v' class='invisible'><code>fn <a href='#method.header_size' class='fnname'>header_size</a>(&amp;mut self) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.u64.html'>u64</a>, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt;</code></span></h4>
<div class='docblock'><p>Get size of retrieved headers</p>

<p>Corresponds to <code>CURLINFO_HEADER_SIZE</code> and may return an error if the
option isn&#39;t supported.</p>
</div><h4 id='method.request_size' class='method'><span id='request_size.v' class='invisible'><code>fn <a href='#method.request_size' class='fnname'>request_size</a>(&amp;mut self) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.u64.html'>u64</a>, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt;</code></span></h4>
<div class='docblock'><p>Get size of sent request.</p>

<p>Corresponds to <code>CURLINFO_REQUEST_SIZE</code> and may return an error if the
option isn&#39;t supported.</p>
</div><h4 id='method.content_type' class='method'><span id='content_type.v' class='invisible'><code>fn <a href='#method.content_type' class='fnname'>content_type</a>(&amp;mut self) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='enum' href='https://doc.rust-lang.org/nightly/core/option/enum.Option.html' title='core::option::Option'>Option</a>&lt;&amp;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.str.html'>str</a>&gt;, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt;</code></span></h4>
<div class='docblock'><p>Get Content-Type</p>

<p>Returns the content-type of the downloaded object. This is the value
read from the Content-Type: field.  If you get <code>None</code>, it means that the
server didn&#39;t send a valid Content-Type header or that the protocol
used doesn&#39;t support this.</p>

<p>Corresponds to <code>CURLINFO_CONTENT_TYPE</code> and may return an error if the
option isn&#39;t supported.</p>
</div><h4 id='method.content_type_bytes' class='method'><span id='content_type_bytes.v' class='invisible'><code>fn <a href='#method.content_type_bytes' class='fnname'>content_type_bytes</a>(&amp;mut self) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='enum' href='https://doc.rust-lang.org/nightly/core/option/enum.Option.html' title='core::option::Option'>Option</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.slice.html'>&amp;[</a><a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.u8.html'>u8</a><a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.slice.html'>]</a>&gt;, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt;</code></span></h4>
<div class='docblock'><p>Get Content-Type, in bytes</p>

<p>Returns the content-type of the downloaded object. This is the value
read from the Content-Type: field.  If you get <code>None</code>, it means that the
server didn&#39;t send a valid Content-Type header or that the protocol
used doesn&#39;t support this.</p>

<p>Corresponds to <code>CURLINFO_CONTENT_TYPE</code> and may return an error if the
option isn&#39;t supported.</p>
</div><h4 id='method.os_errno' class='method'><span id='os_errno.v' class='invisible'><code>fn <a href='#method.os_errno' class='fnname'>os_errno</a>(&amp;mut self) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.i32.html'>i32</a>, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt;</code></span></h4>
<div class='docblock'><p>Get errno number from last connect failure.</p>

<p>Note that the value is only set on failure, it is not reset upon a
successful operation. The number is OS and system specific.</p>

<p>Corresponds to <code>CURLINFO_OS_ERRNO</code> and may return an error if the
option isn&#39;t supported.</p>
</div><h4 id='method.primary_ip' class='method'><span id='primary_ip.v' class='invisible'><code>fn <a href='#method.primary_ip' class='fnname'>primary_ip</a>(&amp;mut self) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='enum' href='https://doc.rust-lang.org/nightly/core/option/enum.Option.html' title='core::option::Option'>Option</a>&lt;&amp;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.str.html'>str</a>&gt;, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt;</code></span></h4>
<div class='docblock'><p>Get IP address of last connection.</p>

<p>Returns a string holding the IP address of the most recent connection
done with this curl handle. This string may be IPv6 when that is
enabled.</p>

<p>Corresponds to <code>CURLINFO_PRIMARY_IP</code> and may return an error if the
option isn&#39;t supported.</p>
</div><h4 id='method.primary_port' class='method'><span id='primary_port.v' class='invisible'><code>fn <a href='#method.primary_port' class='fnname'>primary_port</a>(&amp;mut self) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.u16.html'>u16</a>, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt;</code></span></h4>
<div class='docblock'><p>Get the latest destination port number</p>

<p>Corresponds to <code>CURLINFO_PRIMARY_PORT</code> and may return an error if the
option isn&#39;t supported.</p>
</div><h4 id='method.local_ip' class='method'><span id='local_ip.v' class='invisible'><code>fn <a href='#method.local_ip' class='fnname'>local_ip</a>(&amp;mut self) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='enum' href='https://doc.rust-lang.org/nightly/core/option/enum.Option.html' title='core::option::Option'>Option</a>&lt;&amp;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.str.html'>str</a>&gt;, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt;</code></span></h4>
<div class='docblock'><p>Get local IP address of last connection</p>

<p>Returns a string holding the IP address of the local end of most recent
connection done with this curl handle. This string may be IPv6 when that
is enabled.</p>

<p>Corresponds to <code>CURLINFO_LOCAL_IP</code> and may return an error if the
option isn&#39;t supported.</p>
</div><h4 id='method.local_port' class='method'><span id='local_port.v' class='invisible'><code>fn <a href='#method.local_port' class='fnname'>local_port</a>(&amp;mut self) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.u16.html'>u16</a>, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt;</code></span></h4>
<div class='docblock'><p>Get the latest local port number</p>

<p>Corresponds to <code>CURLINFO_LOCAL_PORT</code> and may return an error if the
option isn&#39;t supported.</p>
</div><h4 id='method.cookies' class='method'><span id='cookies.v' class='invisible'><code>fn <a href='#method.cookies' class='fnname'>cookies</a>(&amp;mut self) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='struct' href='../../curl/easy/struct.List.html' title='curl::easy::List'>List</a>, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt;</code></span></h4>
<div class='docblock'><p>Get all known cookies</p>

<p>Returns a linked-list of all cookies cURL knows (expired ones, too).</p>

<p>Corresponds to the <code>CURLINFO_COOKIELIST</code> option and may return an error
if the option isn&#39;t supported.</p>
</div><h4 id='method.perform' class='method'><span id='perform.v' class='invisible'><code>fn <a href='#method.perform' class='fnname'>perform</a>(&amp;self) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt;</code></span></h4>
<div class='docblock'><p>After options have been set, this will perform the transfer described by
the options.</p>

<p>This performs the request in a synchronous fashion. This can be used
multiple times for one easy handle and libcurl will attempt to re-use
the same connection for all transfers.</p>

<p>This method will preserve all options configured in this handle for the
next request, and if that is not desired then the options can be
manually reset or the <code>reset</code> method can be called.</p>

<p>Note that this method takes <code>&amp;self</code>, which is quite important! This
allows applications to close over the handle in various callbacks to
call methods like <code>unpause_write</code> and <code>unpause_read</code> while a transfer is
in progress.</p>
</div><h4 id='method.transfer' class='method'><span id='transfer.v' class='invisible'><code>fn <a href='#method.transfer' class='fnname'>transfer</a>&lt;'data, 'easy&gt;(&amp;'easy mut self) -&gt; <a class='struct' href='../../curl/easy/struct.Transfer.html' title='curl::easy::Transfer'>Transfer</a>&lt;'easy, 'data&gt;</code></span></h4>
<div class='docblock'><p>Creates a new scoped transfer which can be used to set callbacks and
data which only live for the scope of the returned object.</p>

<p>An <code>Easy</code> handle is often reused between different requests to cache
connections to servers, but often the lifetime of the data as part of
each transfer is unique. This function serves as an ability to share an
<code>Easy</code> across many transfers while ergonomically using possibly
stack-local data as part of each transfer.</p>

<p>Configuration can be set on the <code>Easy</code> and then a <code>Transfer</code> can be
created to set scoped configuration (like callbacks). Finally, the
<code>perform</code> method on the <code>Transfer</code> function can be used.</p>

<p>When the <code>Transfer</code> option is dropped then all configuration set on the
transfer itself will be reset.</p>
</div><h4 id='method.unpause_read' class='method'><span id='unpause_read.v' class='invisible'><code>fn <a href='#method.unpause_read' class='fnname'>unpause_read</a>(&amp;self) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt;</code></span></h4>
<div class='docblock'><p>Unpause reading on a connection.</p>

<p>Using this function, you can explicitly unpause a connection that was
previously paused.</p>

<p>A connection can be paused by letting the read or the write callbacks
return <code>ReadError::Pause</code> or <code>WriteError::Pause</code>.</p>

<p>To unpause, you may for example call this from the progress callback
which gets called at least once per second, even if the connection is
paused.</p>

<p>The chance is high that you will get your write callback called before
this function returns.</p>
</div><h4 id='method.unpause_write' class='method'><span id='unpause_write.v' class='invisible'><code>fn <a href='#method.unpause_write' class='fnname'>unpause_write</a>(&amp;self) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt;</code></span></h4>
<div class='docblock'><p>Unpause writing on a connection.</p>

<p>Using this function, you can explicitly unpause a connection that was
previously paused.</p>

<p>A connection can be paused by letting the read or the write callbacks
return <code>ReadError::Pause</code> or <code>WriteError::Pause</code>. A write callback that
returns pause signals to the library that it couldn&#39;t take care of any
data at all, and that data will then be delivered again to the callback
when the writing is later unpaused.</p>

<p>To unpause, you may for example call this from the progress callback
which gets called at least once per second, even if the connection is
paused.</p>
</div><h4 id='method.url_encode' class='method'><span id='url_encode.v' class='invisible'><code>fn <a href='#method.url_encode' class='fnname'>url_encode</a>(&amp;mut self, s: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.slice.html'>&amp;[</a><a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.u8.html'>u8</a><a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.slice.html'>]</a>) -&gt; <a class='struct' href='https://doc.rust-lang.org/nightly/collections/string/struct.String.html' title='collections::string::String'>String</a></code></span></h4>
<div class='docblock'><p>URL encodes a string <code>s</code></p>
</div><h4 id='method.url_decode' class='method'><span id='url_decode.v' class='invisible'><code>fn <a href='#method.url_decode' class='fnname'>url_decode</a>(&amp;mut self, s: &amp;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.str.html'>str</a>) -&gt; <a class='struct' href='https://doc.rust-lang.org/nightly/collections/vec/struct.Vec.html' title='collections::vec::Vec'>Vec</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.u8.html'>u8</a>&gt;</code></span></h4>
<div class='docblock'><p>URL decodes a string <code>s</code>, returning <code>None</code> if it fails</p>
</div><h4 id='method.reset' class='method'><span id='reset.v' class='invisible'><code>fn <a href='#method.reset' class='fnname'>reset</a>(&amp;mut self)</code></span></h4>
<div class='docblock'><p>Re-initializes this handle to the default values.</p>

<p>This puts the handle to the same state as it was in when it was just
created. This does, however, keep live connections, the session id
cache, the dns cache, and cookies.</p>
</div><h4 id='method.recv' class='method'><span id='recv.v' class='invisible'><code>fn <a href='#method.recv' class='fnname'>recv</a>(&amp;mut self, data: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.slice.html'>&amp;mut [</a><a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.u8.html'>u8</a><a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.slice.html'>]</a>) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.usize.html'>usize</a>, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt;</code></span></h4>
<div class='docblock'><p>Receives data from a connected socket.</p>

<p>Only useful after a successful <code>perform</code> with the <code>connect_only</code> option
set as well.</p>
</div><h4 id='method.send' class='method'><span id='send.v' class='invisible'><code>fn <a href='#method.send' class='fnname'>send</a>(&amp;mut self, data: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.slice.html'>&amp;[</a><a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.u8.html'>u8</a><a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.slice.html'>]</a>) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.usize.html'>usize</a>, <a class='struct' href='../../curl/struct.Error.html' title='curl::Error'>Error</a>&gt;</code></span></h4>
<div class='docblock'><p>Sends data over the connected socket.</p>

<p>Only useful after a successful <code>perform</code> with the <code>connect_only</code> option
set as well.</p>
</div><h4 id='method.raw' class='method'><span id='raw.v' class='invisible'><code>fn <a href='#method.raw' class='fnname'>raw</a>(&amp;self) -&gt; <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.pointer.html'>*mut </a><a class='enum' href='../../curl_sys/enum.CURL.html' title='curl_sys::CURL'>CURL</a></code></span></h4>
<div class='docblock'><p>Get a pointer to the raw underlying CURL handle.</p>
</div></div><h2 id='implementations'>Trait Implementations</h2><h3 class='impl'><span class='in-band'><code>impl <a class='trait' href='https://doc.rust-lang.org/nightly/core/marker/trait.Send.html' title='core::marker::Send'>Send</a> for <a class='struct' href='../../curl/easy/struct.Easy.html' title='curl::easy::Easy'>Easy</a></code></span><span class='out-of-band'><div class='ghost'></div><a id='src-360' class='srclink' href='../../src/curl/easy.rs.html#141' title='goto source code'>[src]</a></span></h3>
<div class='impl-items'></div><h3 class='impl'><span class='in-band'><code>impl <a class='trait' href='https://doc.rust-lang.org/nightly/core/ops/trait.Drop.html' title='core::ops::Drop'>Drop</a> for <a class='struct' href='../../curl/easy/struct.Easy.html' title='curl::easy::Easy'>Easy</a></code></span><span class='out-of-band'><div class='ghost'></div><a id='src-1241' class='srclink' href='../../src/curl/easy.rs.html#3262-3268' title='goto source code'>[src]</a></span></h3>
<div class='impl-items'><h4 id='method.drop' class='method'><span id='drop.v' class='invisible'><code>fn <a href='https://doc.rust-lang.org/nightly/core/ops/trait.Drop.html#tymethod.drop' class='fnname'>drop</a>(&amp;mut self)</code></span></h4>
<div class='docblock'><p>A method called when the value goes out of scope. <a href="https://doc.rust-lang.org/nightly/core/ops/trait.Drop.html#tymethod.drop">Read more</a></p>
</div></div></section>
    <section id='search' class="content hidden"></section>

    <section class="footer"></section>

    <aside id="help" class="hidden">
        <div>
            <h1 class="hidden">Help</h1>

            <div class="shortcuts">
                <h2>Keyboard Shortcuts</h2>

                <dl>
                    <dt>?</dt>
                    <dd>Show this help dialog</dd>
                    <dt>S</dt>
                    <dd>Focus the search field</dd>
                    <dt>&larrb;</dt>
                    <dd>Move up in search results</dd>
                    <dt>&rarrb;</dt>
                    <dd>Move down in search results</dd>
                    <dt>&#9166;</dt>
                    <dd>Go to active search result</dd>
                    <dt>+</dt>
                    <dd>Collapse/expand all sections</dd>
                </dl>
            </div>

            <div class="infos">
                <h2>Search Tricks</h2>

                <p>
                    Prefix searches with a type followed by a colon (e.g.
                    <code>fn:</code>) to restrict the search to a given type.
                </p>

                <p>
                    Accepted types are: <code>fn</code>, <code>mod</code>,
                    <code>struct</code>, <code>enum</code>,
                    <code>trait</code>, <code>type</code>, <code>macro</code>,
                    and <code>const</code>.
                </p>

                <p>
                    Search functions by type signature (e.g.
                    <code>vec -> usize</code> or <code>* -> vec</code>)
                </p>
            </div>
        </div>
    </aside>

    

    <script>
        window.rootPath = "../../";
        window.currentCrate = "curl";
    </script>
    <script src="../../jquery.js"></script>
    <script src="../../main.js"></script>
    <script defer src="../../search-index.js"></script>
</body>
</html>